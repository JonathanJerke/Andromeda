/**
 *  coreForce.c
 *
 *
 *  Copyright 2021 Jonathan Jerke and Bill Poirier.
 *  Ongoing support for this program is coordinated through quantumgalaxies.org.
 *  We acknowledge the generous support of Texas Tech University,
 *  the Robert A. Welch Foundation, and the Army Research Office.
 *
 
 *   *   This file is part of Andromeda.
 
 *   *   Andromeda is free software: you can redistribute it and/or modify
 *   *   it under the terms of the GNU General Public License as published by
 *   *   the Free Software Foundation, either version 3 of the License.
 
 *   *   Andromeda is distributed in the hope that it will be useful,
 *   *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   *   GNU General Public License for more details.
 
 *   *   You should have received a copy of the GNU General Public License
 *   *   along with Andromeda.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "coreForce.h"

/**
 * function description
 * @param[out] outString a FILE to print to
 */
void getDescription (   function_label *fn ,double scalar,FILE * outString){
    //param[1] is unused!
    
    if ( fn->fn == nullFunction){
        fprintf(outString,"\tnullFunction\n");
    }else if ( fn->fn == Pseudo ){
        fprintf(outString,"\tPseudo = %1.3f Erf(r/%1.3f)/r \n",scalar*fn->param[0],fn->param[2]);//, fn->param[1]);
    }else if ( fn->fn == Yukawa ){
        fprintf(outString,"\tYukawa = %1.3f exp(- r %1.3f)/r \n",scalar*fn->param[0],fn->param[2]);//, fn->param[1]);
    }else if ( fn->fn == Coulomb ){
        fprintf(outString,"\tCoulomb = %1.3f /r \n",scalar*fn->param[0]);//,fn->param[1]);
    }else if ( fn->fn == Morse ){
        fprintf(outString,"\tMorse = %1.3f (1-exp[-%1.3f *( r - %1.3f )] )^2 -1 \n",scalar*fn->param[0],fn->param[3],fn->param[2]);//,fn->param[1]);
    }else if ( fn->fn == LennardJones ){
        fprintf(outString,"\tLennardJones = %1.3f  rm = %f\n",scalar* fn->param[0],fn->param[2]);
    }
    else if ( fn->fn == Gaussian ){
        fprintf(outString,"\t %f Gaussian --width %f\n",scalar * fn->param[0],fn->param[2]);
    }

    fflush(outString);
}

/**
 * metric description
 * @param[out] outString a string to print
*/
void getMetric (   metric_label mu,FILE * outString){
    switch ( mu.metric ){
        case dirac:
            fprintf(outString,"\tDirac @ %f \n", mu.beta[0]);
            break;
        case separateDirac:
            fprintf(outString,"\tseparated Dirac @ %f \n", mu.beta[0]);
            fprintf(outString,"\tpowA %d %d %d\n" , mu.pow[0],mu.pow[1],mu.pow[2]);
            fprintf(outString,"\tpowB %d %d %d\n" , mu.powB[0],mu.powB[1],mu.powB[2]);
            break;
        case interval:
            fprintf(outString,"\tInterval [%f,%f]\n", mu.beta[0],mu.beta[1]);
        //    printf("deriv %d %d %d\n" , mu.deriv[0],mu.deriv[1],mu.deriv[2]);
        //    printf("pow %d %d %d\n" , mu.pow[0],mu.pow[1],mu.pow[2]);
            break;
        case semiIndefinite:
            fprintf(outString,"\tSemi-Interval [%f,inf) \n", mu.beta[0]);
        ///    printf("deriv %d %d %d\n" , mu.deriv[0],mu.deriv[1],mu.deriv[2]);
        ///    printf("pow %d %d %d\n" , mu.pow[0],mu.pow[1],mu.pow[2]);
            break;
            default:
                break;

    }
    return;
}

/**
 *Basis overlap Basis
 */
mea BoB (  basisElement_label b1,   basisElement_label b2 ){
    if ( b1.basis == SincBasisElement && b2.basis == SincBasisElement ){
        return spatialSincfourierIntegralInTrain(b1.index, b1.length, b1.origin, b1.grid, b2.index, b2.length, b2.origin, b2.grid, 0);
    }else     if ( b1.basis == PeriodicSincBasisElement && b2.basis == PeriodicSincBasisElement ){
        floata crystal = 0.;
        return periodicSincfourierIntegralInTrain(b1.index, b1.length, b1.origin, b1.grid, b2.index, b2.length, b2.origin, b2.grid, crystal, 0, 0);
    }

    return 0;
}

/**
 *This differentiates one potential from another
 *
 *The beta dependence is critical
*/
double inverseLaplaceTransform(double beta,   function_label * fl){
    double value2;
    value2 = 0.0;
    if ( fl->fn == Gaussian ){
        return 1;//identity!  differ from Coulomb by some cofactors
    }
    if ( fl->fn == Yukawa ){
        double m = fl->param[2];
        value2  += exp(-(m/2./beta)*(m/2./beta));
    }
    else if ( fl->fn == Morse ){
        double R = fl->param[2];
        double a = fl->param[3];
        value2  += - a * exp (     R * a - (a/beta /2.)*(a/beta /2.))/(beta*beta);
        value2  +=   a * exp ( 2 * R * a - (a/beta    )*(a/beta    ))/(beta*beta);
        value2 *= 1.;
    }
    else if ( fl->fn == Coulomb || fl->fn == Pseudo || fl->fn == nullFunction  ){
            value2 += 1.;//
    } else if ( fl->fn == LennardJones ){
        double rm = fl->param[2];
        value2 +=  1 *   ( 1./60 *  rm * pow(rm * beta,11) ) ;
        value2 += -2 *   ( 1.    *  rm * pow(rm * beta,5 ) ) ;///should be separate canon-ranks
    }
    return 2./sqrt(pi)*value2*fl->param[0];
}

/**
 *Gauss Konrod quadrature
 *
 * https://keisan.casio.com/exec/system/1329114617
 */
double gaussQuad(inta pt , inta nm, inta which , inta truncate){

    double gk1X [] = {
        0
    };
    double gk1W [] = {
        1
    };

    double gk3X [] = {
        -0.7745966692414833770359,
        0,
        0.7745966692414833770359
    };
    
    double gk3W [] = {
        0.5555555555555555555556,
        0.8888888888888888888889,
        0.555555555555555555556
    };
    
    double gk7X [] = {
        0.949107912342759
        ,0.741531185599394
        ,0.405845151377397
        ,0.0
        ,-0.405845151377397
        ,-0.741531185599394
        ,-0.949107912342759
    };//7
    
    double gk7W [] = {
        0.129484966168870
        ,0.279705391489277
        ,0.381830050505119
        ,0.417959183673469
        ,0.381830050505119
        ,0.279705391489277
        ,0.129484966168870};
    
    ///Chebyshev 2nd
    double cB9X[] = {-0.9510565162951535721164,
                     -0.809016994374947424102,
                     -0.5877852522924731291687,
                     -0.3090169943749474241023,
                     0,
                     0.3090169943749474241023,
                     0.5877852522924731291687,
                     0.809016994374947424102,
        0.9510565162951535721164};
    ///Chebyshev 2nd
    double cB9W[] = {0.02999954037160816652789,
        0.1085393567113529974895,
        0.2056199086476263263568,
        0.2841597249873711573184,
        0.314159265358979323846,
        0.2841597249873711573184,
        0.2056199086476263263568,
        0.1085393567113529974895,
        0.0299995403716081665279};
    
    double gk10X[] = {
        -0.9840853600948424644962,
        -0.9061798459386639927976,
        -0.7541667265708492204408,
        -0.5384693101056830910363,
        -0.2796304131617831934135,
        0,
        0.2796304131617831934135,
        0.5384693101056830910363,
        0.7541667265708492204408,
        0.9061798459386639927976
    };
    
    double gk10W[]= {
        0.04258203675108183286451,
        0.1152333166224733940246,
        0.186800796556492657468,
        0.2410403392286475866999,
        0.272849801912558922341,
        0.2829874178574912132043,
        0.272849801912558922341,
        0.2410403392286475866999,
        0.1868007965564926574678,
        0.1152333166224733940246
    };
    
    
    
    
    double gk15X [] = {
        0.991455371120813
        ,0.949107912342759
        ,0.864864423359769
        ,0.741531185599394
        ,0.586087235467691
        ,0.405845151377397
        ,0.207784955007898
        ,0.0
        ,-0.207784955007898
        ,-0.405845151377397
        ,-0.586087235467691
        ,-0.741531185599394
        ,-0.864864423359769
        ,-0.949107912342759
        ,-0.991455371120813
    };//8
    
    
    double gk15W [] = {
        0.022935322010529
        ,0.063092092629979
        ,0.104790010322250
        ,0.140653259715525
        ,0.169004726639267
        ,0.190350578064785
        ,0.204432940075298
        ,0.209482141084728
        ,0.204432940075298
        ,0.190350578064785
        ,0.169004726639267
        ,0.140653259715525
        ,0.104790010322250
        ,0.063092092629979
        ,0.022935322010529
    };
    ///Chebyshev 2nd

    double cy18X[] = {-0.9863613034027223736025,
        -0.9458172417006346790197,
        -0.8794737512064890713909,
        -0.789140509396393599219,
        -0.6772815716257410747622,
        -0.5469481581224268747118,
        -0.4016954246529694575168,
        -0.2454854871407991489223,
        -0.0825793454723323246003,
        0.0825793454723323246003,
        0.2454854871407991489223,
        0.4016954246529694575168,
        0.5469481581224268747118,
        0.6772815716257410747622,
        0.789140509396393599219,
        0.8794737512064890713909,
        0.9458172417006346790197,
        0.9863613034027223736025};
    ///Chebyshev 2nd

    double cy18W[] = {0.0044794777743294076695,
        0.0174324901742098922585,
        0.0374553773194186412865,
        0.0623783487006670256632,
        0.0895006136490506848368,
        0.115883053912110379111,
        0.138666722721604493581,
        0.1553826560369778121825,
        0.1642194231090799730263,
        0.164219423109079973026,
        0.1553826560369778121825,
        0.1386667227216044935815,
        0.115883053912110379111,
        0.0895006136490506848368,
        0.0623783487006670256632,
        0.0374553773194186412865,
        0.01743249017420989225845,
        0.0044794777743294076695};

    
    double la34X[] = {-1,
        -0.9934643625875162022546,
        -0.9781466888799379489452,
        -0.9542306489128075284072,
        -0.9219282956774489227428,
        -0.8815238365122732643985,
        -0.8333724428031426149123,
        -0.777897306431867410882,
        -0.7155859607202190059973,
        -0.6469860079360146243772,
        -0.5727003112749228447909,
        -0.4933816986732709574365,
        -0.4097272265595927448574,
        -0.3224720545114889935775,
        -0.2323829848691168430633,
        -0.1402517241761938583713,
        -0.0468879257129706800868,
        0.04688792571297068008684,
        0.1402517241761938583713,
        0.232382984869116843063,
        0.3224720545114889935775,
        0.4097272265595927448574,
        0.4933816986732709574365,
        0.5727003112749228447909,
        0.6469860079360146243772,
        0.7155859607202190059973,
        0.777897306431867410882,
        0.8333724428031426149123,
        0.8815238365122732643985,
        0.9219282956774489227428,
        0.9542306489128075284072,
        0.9781466888799379489452,
        0.9934643625875162022546,
        1};
    
    double la34W[] = {0.001782531194295900178253,
        0.0109647408183065514015,
        0.019646278160713431288,
        0.02815053686224350340075,
        0.0364067709507825523508,
        0.04434290206024434230027,
        0.051889291830927120776,
        0.0589796540267452266954,
        0.0655516901082651204304,
        0.0715476498770728220356,
        0.0769148430635909821051,
        0.0816061038504223831621,
        0.0855802059719775865901,
        0.0888022252835840321182,
        0.0912438468069144870224,
        0.0928836136296106461437,
        0.0937071155043033120016,
        0.0937071155043033120016,
        0.0928836136296106461437,
        0.0912438468069144870224,
        0.0888022252835840321182,
        0.0855802059719775865901,
        0.081606103850422383162,
        0.076914843063590982105,
        0.071547649877072822036,
        0.0655516901082651204304,
        0.058979654026745226695,
        0.051889291830927120776,
        0.0443429020602443423003,
        0.036406770950782552351,
        0.0281505368622435034008,
        0.01964627816071343128795,
        0.0109647408183065514015,
        0.001782531194295900178253};
    
    double gk35X [] = {-0.9984329706060580765167,
        -0.990575475314417335675,
        -0.9746592569674310674486,
        -0.9506755217687677612227,
        -0.9190961368038916732426,
        -0.880239153726985902123,
        -0.834274092850134363076,
        -0.7815140038968014069252,
        -0.722472287372409906023,
        -0.6576711592166907658503,
        -0.5875692123340352515726,
        -0.512690537086476967886,
        -0.4336872952097993710771,
        -0.3512317634538763152972,
        -0.2659465074516820191091,
        -0.1784841814958478558507,
        -0.0895856394252266354625,
        0.00,
        0.0895856394252266354625,
        0.1784841814958478558507,
        0.2659465074516820191091,
        0.3512317634538763152972,
        0.4336872952097993710771,
        0.5126905370864769678863,
        0.5875692123340352515726,
        0.6576711592166907658503,
        0.7224722873724099060232,
        0.7815140038968014069252,
        0.834274092850134363076,
        0.880239153726985902123,
        0.9190961368038916732426,
        0.9506755217687677612227,
        0.9746592569674310674486,
        0.9905754753144173356754,
        0.9984329706060580765167};
    
    double gk35W[] = {0.0042189757937769386559,
        0.0117858375622890860476,
        0.020022233953295123733,
        0.02785672245786342694433,
        0.0352497467518800321001,
        0.04244263020500089117947,
        0.0494361418239590678556,
        0.0559940445300935170357,
        0.062000915268229960367,
        0.067528016718131089923,
        0.072589890114190143846,
        0.0770562230462021636789,
        0.0808366784408178713044,
        0.0839725719912347754276,
        0.0864905322056519368263,
        0.0883087822976044066468,
        0.08936184586778888574733,
        0.0896964219439813653622,
        0.0893618458677888857473,
        0.0883087822976044066468,
        0.086490532205651936826,
        0.08397257199123477542758,
        0.080836678440817871304,
        0.0770562230462021636789,
        0.0725898901141901438458,
        0.067528016718131089923,
        0.062000915268229960367,
        0.05599404453009351703567,
        0.0494361418239590678556,
        0.0424426302050008911795,
        0.0352497467518800321001,
        0.0278567224578634269443,
        0.020022233953295123733,
        0.0117858375622890860476,
        0.00421897579377693865586};
    
    
    ///Chebyshev 2nd
    double cB36X[] = {-0.9963974885425265016515,
        -0.9856159103477084622648,
        -0.9677329469334988386885,
        -0.942877445461084170041,
        -0.9112284903881357028266,
        -0.8730141131611881587491,
        -0.8285096492438421235308,
        -0.7780357543184395071379,
        -0.7219560939545244623539,
        -0.6606747233900814419084,
        -0.5946331763042866161328,
        -0.5243072835572316877978,
        -0.450203744817673292456,
        -0.3728564777803086108307,
        -0.2928227712765503799534,
        -0.2106792699957263203605,
        -0.1270178197468787473746,
        -0.0424412031961483058781,
        0.0424412031961483058781,
        0.1270178197468787473746,
        0.210679269995726320361,
        0.2928227712765503799534,
        0.3728564777803086108307,
        0.450203744817673292456,
        0.5243072835572316877978,
        0.5946331763042866161328,
        0.6606747233900814419084,
        0.7219560939545244623539,
        0.7780357543184395071379,
        0.8285096492438421235308,
        0.8730141131611881587491,
        0.9112284903881357028266,
        0.942877445461084170041,
        0.9677329469334988386885,
        0.9856159103477084622648,
        0.9963974885425265016515};
    ///Chebyshev 2nd

    double cB36W[] = {0.00061066149162454132948,
        0.00242507834721270635697,
        0.0053910530973296769346,
        0.00942326004855122207073,
        0.0144056999483114140921,
        0.0201950370721996428695,
        0.0266247227317812125553,
        0.0335097865771291740553,
        0.04065215785701705497487,
        0.0478463635538051362452,
        0.0548854394680541653226,
        0.0615668842017244540976,
        0.06769848475470411339,
        0.073103846142860943624,
        0.0776274659605743790319,
        0.08113920790182267409669,
        0.0835380455447685732217,
        0.0847549686979772253469,
        0.0847549686979772253469,
        0.08353804554476857322175,
        0.0811392079018226740967,
        0.077627465960574379032,
        0.0731038461428609436241,
        0.06769848475470411339,
        0.0615668842017244540976,
        0.0548854394680541653226,
        0.047846363553805136245,
        0.040652157857017054975,
        0.0335097865771291740553,
        0.02662472273178121255531,
        0.020195037072199642869,
        0.0144056999483114140921,
        0.0094232600485512220707,
        0.00539105309732967693461,
        0.00242507834721270635697,
        0.00061066149162454132948};
    
    
    ///Chebyshev 1st
    double cA37X[] = {-0.9990989662046814723577,
        -0.9919004352588768873144,
        -0.9775552389476861943403,
        -0.9561667347392509355063,
        -0.9278890272965093271272,
        -0.8929258581495684897301,
        -0.851529137733311299887,
        -0.8039971303669405448264,
        -0.750672305252724355285,
        -0.69193886897754620001,
        -0.6282199972956423167889,
        -0.5599747861375953903804,
        -0.4876949438136345453546,
        -0.411901248243992675383,
        -0.333139794742057566801,
        -0.2519780613851251944453,
        -0.169000820321849074093,
        -0.0848059244755091910885,
        0,
        0.0848059244755091910885,
        0.169000820321849074093,
        0.2519780613851251944453,
        0.333139794742057566801,
        0.411901248243992675383,
        0.4876949438136345453546,
        0.5599747861375953903804,
        0.6282199972956423167889,
        0.6919388689775462000101,
        0.7506723052527243552854,
        0.8039971303669405448264,
        0.851529137733311299887,
        0.8929258581495684897301,
        0.9278890272965093271272,
        0.9561667347392509355063,
        0.9775552389476861943403,
        0.9919004352588768873144,
        0.9990989662046814723577};
    ///Chebyshev 1st

    double cA37W [] = {0.084907909556480898337,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.084907909556480898337,
        0.084907909556480898337,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.0849079095564808983368,
        0.0849079095564808983368,
        0.08490790955648089833683,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.0849079095564808983368,
        0.0849079095564808983368,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.08490790955648089833683,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.0849079095564808983368,
        0.084907909556480898337,
        0.084907909556480898337,
        0.084907909556480898337,
        0.084907909556480898337,
        0.084907909556480898337};
    
    double la37X[] = {-1,
        -0.9944938094532618479785,
        -0.9815814149869770840465,
        -0.9613997340068480861054,
        -0.9340997654697049941293,
        -0.899883908976607050629,
        -0.859005567046514524498,
        -0.8117674185836550836616,
        -0.7585192115735683755891,
        -0.6996551837323294321503,
        -0.6356111473464340479732,
        -0.5668612641786996769424,
        -0.4939145356334208327143,
        -0.4173110346338307713513,
        -0.337617907295764718093,
        -0.2554251740807967521403,
        -0.1713413615537253984006,
        -0.085988997104455259539,
        0,
        0.0859889971044552595389,
        0.1713413615537253984006,
        0.2554251740807967521403,
        0.337617907295764718093,
        0.4173110346338307713513,
        0.4939145356334208327143,
        0.5668612641786996769424,
        0.6356111473464340479732,
        0.6996551837323294321503,
        0.7585192115735683755891,
        0.8117674185836550836616,
        0.8590055670465145244985,
        0.899883908976607050629,
        0.9340997654697049941293,
        0.9613997340068480861054,
        0.9815814149869770840465,
        0.9944938094532618479785,
        1};
    
    double la37W [] = {0.001501501501501501501502,
        0.0092392432428419296555,
        0.016568023462080861143,
        0.0237702445815514586944,
        0.0307959434086980844112,
        0.0375935062039168280197,
        0.044112694216875663982,
        0.0503052683150415569499,
        0.0561253907738756298871,
        0.0615299757164856086336,
        0.0664790115346973363994,
        0.0709358583644536437571,
        0.0748675198627182373963,
        0.0782448877288513821639,
        0.0810429573225037171132,
        0.0832410128457917439415,
        0.084822780746207937208,
        0.0857765502170993864,
        0.0860952599096149854858,
        0.0857765502170993864,
        0.084822780746207937208,
        0.0832410128457917439415,
        0.0810429573225037171132,
        0.078244887728851382164,
        0.074867519862718237396,
        0.0709358583644536437571,
        0.0664790115346973363994,
        0.061529975716485608634,
        0.056125390773875629887,
        0.0503052683150415569499,
        0.044112694216875663982,
        0.0375935062039168280197,
        0.0307959434086980844112,
        0.0237702445815514586944,
        0.0165680234620808611434,
        0.0092392432428419296555,
        0.001501501501501501501502};
    
    ///RECURSIVE FORMULA : found at http://www.bnikolic.co.uk/nqm/1dinteg/gausslobatto.html//by evaluating 2 levels deep their recursion
    /// <00|G(beta =1)|00> is 0.691486310571776
    ///yields 0.691485415319 with this quadrature
    
    double rla37X [] = {-1., -0.983163, -0.949281, -0.908248, -0.867216, -0.833333, \
        -0.816497, -0.782614, -0.714429, -0.631855, -0.549281, -0.481096, \
        -0.447214, -0.406181, -0.323607, -0.223607, -0.123607, -0.0410326, \
        0., 0.0410326, 0.123607, 0.223607, 0.323607, 0.406181, 0.447214, \
        0.481096, 0.549281, 0.631855, 0.714429, 0.782614, 0.816497, 0.833333, \
        0.867216, 0.908248, 0.949281, 0.983163, 1.};
    
    double rla37W[] = {0.00480604, 0.0269638, 0.0390101, 0.0419436, 0.0390101, 0.0269638, \
        0.0144777, 0.054262, 0.078504, 0.0844075, 0.078504, 0.054262, \
        0.0213844, 0.065713, 0.0950709, 0.10222, 0.0950709, 0.065713, \
        0.0234255, 0.065713, 0.0950709, 0.10222, 0.0950709, 0.065713, \
        0.0213844, 0.054262, 0.078504, 0.0844075, 0.078504, 0.054262, \
        0.0144777, 0.0269638, 0.0390101, 0.0419436, 0.0390101, 0.0269638, \
        0.00480604};
    
    double cA48X[] = {-0.9994645874763656444298,
        -0.9951847266721968862448,
        -0.9866433320848790047469,
        -0.9738769792773336481497,
        -0.9569403357322088649358,
        -0.9359059267573257002917,
        -0.9108638249211758185733,
        -0.8819212643483550297128,
        -0.8492021815265788876491,
        -0.812846684591615216579,
        -0.7730104533627369608109,
        -0.7298640726978356573501,
        -0.683592302022871280514,
        -0.634393284163645498215,
        -0.5824776968678021491971,
        -0.5280678506503679958735,
        -0.4713967368259976485564,
        -0.412707029804394737048,
        -0.3522500479212335065318,
        -0.2902846772544623676362,
        -0.2270762630343732075857,
        -0.162895473394588739481,
        -0.0980171403295606019942,
        -0.0327190828217761420637,
        0.0327190828217761420637,
        0.0980171403295606019942,
        0.162895473394588739481,
        0.2270762630343732075857,
        0.2902846772544623676362,
        0.3522500479212335065318,
        0.412707029804394737048,
        0.471396736825997648556,
        0.5280678506503679958735,
        0.5824776968678021491971,
        0.6343932841636454982152,
        0.6835923020228712805135,
        0.7298640726978356573501,
        0.7730104533627369608109,
        0.812846684591615216579,
        0.8492021815265788876491,
        0.8819212643483550297128,
        0.9108638249211758185733,
        0.9359059267573257002917,
        0.9569403357322088649358,
        0.9738769792773336481497,
        0.9866433320848790047469,
        0.9951847266721968862448,
        0.9994645874763656444298};
    
    double cA48W[]  = {0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.06544984694978735913464,
        0.0654498469497873591346,
        0.0654498469497873591346,
        0.0654498469497873591346,
        0.06544984694978735913464,
        0.065449846949787359135,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.06544984694978735913464,
        0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.065449846949787359135,
        0.06544984694978735913464,
        0.06544984694978735913,
        0.0654498469497873591346,
        0.065449846949787359135,
        0.065449846949787359135};
    
    double la48X[] = {-1,
        -0.9967477813398574644046,
        -0.9891114700136357278916,
        -0.9771488468908367728799,
        -0.9609131535063815901055,
        -0.9404755493350812951993,
        -0.9159254499762464200775,
        -0.8873702243182200971957,
        -0.8549347448387740702695,
        -0.818760847485605868698,
        -0.7790067135998438219706,
        -0.7358461791128483687624,
        -0.6894679748110907103729,
        -0.6400749012659571378282,
        -0.5878829421454851810262,
        -0.5331203198327769611048,
        -0.4760264975028570780217,
        -0.4168511320327026699131,
        -0.3558529823289060438219,
        -0.2932987778497592653591,
        -0.229462052271244570326,
        -0.1646219473980906274779,
        -0.099061992550750112347,
        -0.0330688647661529110911,
        0.0330688647661529110911,
        0.099061992550750112347,
        0.164621947398090627478,
        0.229462052271244570326,
        0.2932987778497592653591,
        0.3558529823289060438219,
        0.4168511320327026699131,
        0.4760264975028570780217,
        0.5331203198327769611048,
        0.5878829421454851810262,
        0.6400749012659571378282,
        0.689467974811090710373,
        0.7358461791128483687624,
        0.7790067135998438219706,
        0.8187608474856058686977,
        0.8549347448387740702695,
        0.8873702243182200971957,
        0.9159254499762464200775,
        0.9404755493350812951993,
        0.9609131535063815901055,
        0.9771488468908367728799,
        0.9891114700136357278916,
        0.9967477813398574644046,
        1};
    
    double la48W[] = {8.865248226950354609929E-4,
        0.00545919260024811922,
        0.00980693197890032805314,
        0.014109490605488713237,
        0.0183500364752190814685,
        0.02251026373693608449877,
        0.0265720325909113171223,
        0.03051759762130364252948,
        0.0343297117006738369802,
        0.0379917079267281565257,
        0.0414875745188472911245,
        0.0448020255640716104804,
        0.0479205681567355006606,
        0.0508295659059446972544,
        0.0535162986286749312254,
        0.0559690180051488355827,
        0.0581769989692746316579,
        0.0601305866168440230509,
        0.0618212384299793668072,
        0.0632415616350379856623,
        0.064385345531601176533,
        0.0652475886517258235761,
        0.0658245206310080170951,
        0.066113618696001794193,
        0.0661136186960017941932,
        0.0658245206310080170951,
        0.065247588651725823576,
        0.064385345531601176533,
        0.063241561635037985662,
        0.061821238429979366807,
        0.0601305866168440230509,
        0.058176998969274631658,
        0.0559690180051488355827,
        0.053516298628674931225,
        0.0508295659059446972544,
        0.047920568156735500661,
        0.0448020255640716104804,
        0.041487574518847291125,
        0.0379917079267281565257,
        0.03432971170067383698,
        0.030517597621303642529,
        0.026572032590911317122,
        0.022510263736936084499,
        0.018350036475219081469,
        0.014109490605488713237,
        0.009806931978900328053,
        0.00545919260024811922019,
        8.865248226950354609929E-4};
    
    double gk49X [] = {-0.9992010560218750516558,
        -0.99518721999702136018,
        -0.9870404960158090456619,
        -0.9747285559713094981984,
        -0.9584416844052094070009,
        -0.9382745520027327585237,
        -0.914240690794911500875,
        -0.8864155270044010342132,
        -0.8549538039040513668272,
        -0.820001985973902921954,
        -0.7816772264764643171707,
        -0.7401241915785543642438,
        -0.6955320723967788024617,
        -0.6480936519369755692525,
        -0.5979905139060783797033,
        -0.5454214713888395356584,
        -0.4906123654634464160383,
        -0.4337935076260451384871,
        -0.3751911547979508704127,
        -0.3150426796961633743868,
        -0.2536004303696779105375,
        -0.1911188674736163091586,
        -0.1278512402862166993267,
        -0.064056892862605626085,
        0,
        0.064056892862605626085,
        0.1278512402862166993267,
        0.191118867473616309159,
        0.2536004303696779105375,
        0.3150426796961633743868,
        0.375191154797950870413,
        0.4337935076260451384871,
        0.4906123654634464160383,
        0.5454214713888395356584,
        0.5979905139060783797033,
        0.6480936519369755692525,
        0.6955320723967788024617,
        0.7401241915785543642438,
        0.7816772264764643171707,
        0.820001985973902921954,
        0.8549538039040513668272,
        0.8864155270044010342132,
        0.914240690794911500875,
        0.9382745520027327585237,
        0.9584416844052094070009,
        0.9747285559713094981984,
        0.9870404960158090456619,
        0.99518721999702136018,
        0.9992010560218750516558};
    
    
    double gk49W[] = {0.0021523085509462220609,
        0.006025671015720143722,
        0.0102597864092807612456,
        0.0143274446308838458486,
        0.0182311785503872701985,
        0.02210408490006188964019,
        0.02595119466137410640556,
        0.0296713060906591174913,
        0.0332273783198295724343,
        0.036658100242212953887,
        0.0399676238936221812226,
        0.043105928193695268093,
        0.0460458917765638334117,
        0.04880138675325905145,
        0.0513719513834576384873,
        0.05372794550175131739513,
        0.0558517151030633195552,
        0.0577486753756900345399,
        0.0594165432459520976944,
        0.060838034873127860984,
        0.0620040014197812739399,
        0.062917112269698113171,
        0.0635748787129724207348,
        0.0639696262413763475096,
        0.0641004637692667177568,
        0.06396962624137634751,
        0.0635748787129724207348,
        0.062917112269698113171,
        0.0620040014197812739399,
        0.0608380348731278609836,
        0.0594165432459520976944,
        0.05774867537569003453994,
        0.0558517151030633195552,
        0.0537279455017513173951,
        0.0513719513834576384873,
        0.04880138675325905145005,
        0.046045891776563833412,
        0.0431059281936952680928,
        0.0399676238936221812226,
        0.036658100242212953887,
        0.033227378319829572434,
        0.029671306090659117491,
        0.0259511946613741064056,
        0.02210408490006188964,
        0.0182311785503872701985,
        0.0143274446308838458486,
        0.0102597864092807612456,
        0.006025671015720143722,
        0.0021523085509462220609};
    
    
    
    
    
    ///Chebyshev 2nd
    double cB50X[] = {-0.9981033287370440781596,
        -0.9924205096719357582615,
        -0.982973099683901778282
        -0.9697969360350094718195,
        -0.952942000427156555831,
        -0.9324722294043558045731,
        -0.9084652718195236861115,
        -0.8810121942857845060087,
        -0.8502171357296141521341,
        -0.8161969123562216908719,
        -0.7790805745256704319244,
        -0.739008917220659115925,
        -0.69613394596292660828,
        -0.6506183002042421137201,
        -0.602634636379256389179,
        -0.5523649729605058107631,
        -0.5,
        -0.4457383557765382673965,
        -0.3897858732926793690829,
        -0.332354799479659664562,
        -0.2736629900720828635391,
        -0.2139330832064974399065,
        -0.1533916548786853726488,
        -0.0922683594633019952397,
        -0.0307950585561703538746,
        0.0307950585561703538746,
        0.0922683594633019952397,
        0.1533916548786853726488,
        0.2139330832064974399065,
        0.2736629900720828635391,
        0.3323547994796596645619,
        0.3897858732926793690829,
        0.4457383557765382673965,
        0.5,
        0.5523649729605058107631,
        0.602634636379256389179,
        0.6506183002042421137201,
        0.6961339459629266082805,
        0.739008917220659115925,
        0.7790805745256704319244,
        0.8161969123562216908719,
        0.8502171357296141521341,
        0.8810121942857845060087,
        0.9084652718195236861115,
        0.9324722294043558045731,
        0.952942000427156555831,
        0.9697969360350094718195,
        0.982973099683901778282,
        0.9924205096719357582615,
        0.9981033287370440781596};
    ///Chebyshev 2nd

    double cB50W[] = {0.00023344775620197562455,
        0.00093025219478742015151,
        0.0020798504707507123594,
        0.00366481584606420604756,
        0.0056611218612628905433,
        0.0080385065520786560541,
        0.01076093118997125039496,
        0.0137871265925170921372,
        0.0170712187221473239164,
        0.02056342408979593725324,
        0.0242108044218475187591,
        0.0279580691504029550251,
        0.03174841356192868164045,
        0.0355243798988103154153,
        0.03922872836038887533457,
        0.04280530479999173270171,
        0.0461998919645557829186,
        0.0493610313729178575109,
        0.0522408033739352703511,
        0.05479555355955053806244,
        0.056986554521118678149,
        0.0587805929174457202687,
        0.060150472955185391024,
        0.061075428649344378189,
        0.0615414386144471497835,
        0.061541438614447149784,
        0.0610754286493443781889,
        0.060150472955185391024,
        0.0587805929174457202687,
        0.0569865545211186781491,
        0.0547955535595505380624,
        0.052240803373935270351,
        0.0493610313729178575109,
        0.046199891964555782919,
        0.042805304799991732702,
        0.0392287283603888753346,
        0.03552437989881031541528,
        0.0317484135619286816405,
        0.0279580691504029550251,
        0.024210804421847518759,
        0.0205634240897959372532,
        0.0170712187221473239164,
        0.0137871265925170921372,
        0.010760931189971250395,
        0.0080385065520786560541,
        0.0056611218612628905433,
        0.00366481584606420604756,
        0.00207985047075071235942,
        0.00093025219478742015151,
        0.00023344775620197562455};
    
    
    double cB51X[]= {-0.9981755542233174708417,
        -0.9927088740980539928008,
        -0.9836199069471435884212,
        -0.970941817426052027157,
        -0.9547208665085456260632,
        -0.9350162426854148234398,
        -0.9118998459920900771752,
        -0.8854560256532098959004,
        -0.855781272301447522643,
        -0.8229838658936563945796,
        -0.7871834806090501817972,
        -0.748510748171101098635,
        -0.7071067811865475244008,
        -0.663122658240795202377,
        -0.6167188726285430584574,
        -0.5680647467311558025118,
        -0.5173378141776567710363,
        -0.464723172043768545656,
        -0.4104128054527567964243,
        -0.3546048870425356259696,
        -0.2975030538552029766545,
        -0.2393156642875577671488,
        -0.1802550378139057401699,
        -0.1205366802553230533491,
        -0.060378497422286053438,
        0,
        0.060378497422286053438,
        0.1205366802553230533491,
        0.18025503781390574017,
        0.2393156642875577671488,
        0.2975030538552029766545,
        0.3546048870425356259696,
        0.4104128054527567964243,
        0.464723172043768545656,
        0.517337814177656771036,
        0.5680647467311558025118,
        0.6167188726285430584574,
        0.6631226582407952023768,
        0.7071067811865475244008,
        0.7485107481711010986346,
        0.7871834806090501817972,
        0.8229838658936563945796,
        0.855781272301447522643,
        0.8854560256532098959004,
        0.9118998459920900771752,
        0.9350162426854148234398,
        0.9547208665085456260632,
        0.970941817426052027157,
        0.9836199069471435884212,
        0.9927088740980539928008,
        0.9981755542233174708417};
    
    double cB51W[] = {2.2024757278799837863E-4,
        8.7777858558640288742E-4,
        0.00196300475559771904902,
        0.0034601010415466685264,
        0.0053472364084168722161,
        0.007596892173100598672,
        0.0101762632887651525548,
        0.013047736716306227466,
        0.0161694399071552345805,
        0.0194958513993262005069,
        0.0229784646228369280502,
        0.0265664952347266197204,
        0.0302076216691326272929,
        0.0338487481035386348655,
        0.0374367787154283265356,
        0.0409193919389390540789,
        0.0442458034311100200054,
        0.0473675066219590271198,
        0.050238980049500102031,
        0.0528183511651646559139,
        0.05506800692984838237,
        0.0569551422967185860594,
        0.0584522385826675355368,
        0.0595374647526788516984,
        0.0601949957654772562072,
        0.0604152433382652545858,
        0.0601949957654772562072,
        0.059537464752678851698,
        0.058452238582667535537,
        0.056955142296718586059,
        0.0550680069298483823697,
        0.0528183511651646559139,
        0.050238980049500102031,
        0.0473675066219590271198,
        0.0442458034311100200054,
        0.040919391938939054079,
        0.0374367787154283265356,
        0.0338487481035386348655,
        0.0302076216691326272929,
        0.0265664952347266197204,
        0.0229784646228369280502,
        0.0194958513993262005069,
        0.01616943990715523458047,
        0.013047736716306227466,
        0.0101762632887651525548,
        0.007596892173100598672,
        0.0053472364084168722161,
        0.0034601010415466685264,
        0.001963004755597719049,
        8.777785855864028874E-4,
        2.2024757278799837863E-4};
    
    
    ///Chebyshev 1st
    double cA51X [] = {-0.9995257197133658746659,
        -0.9957341762950345218712,
        -0.988165472081259413762,
        -0.9768483177596007116214,
        -0.9618256431728190704088,
        -0.9431544344712774640574,
        -0.9209055179449536255994,
        -0.895163291355062322067,
        -0.8660254037844386467637,
        -0.8336023852211194846165,
        -0.7980172272802395033328,
        -0.759404916654707132483,
        -0.717911923064441921752,
        -0.6736956436465572117127,
        -0.6269238058941064650172,
        -0.5777738314082511021102,
        -0.5264321628773558002446,
        -0.4730935568360100744212,
        -0.417960344886783419761,
        -0.3612416661871529487447,
        -0.3031526741130434999087,
        -0.243913720108377148657,
        -0.1837495178165703315744,
        -0.122888290664714122267,
        -0.061560906133942837451,
        0,
        0.0615609061339428374505,
        0.1228882906647141222666,
        0.183749517816570331574,
        0.243913720108377148657,
        0.3031526741130434999087,
        0.3612416661871529487447,
        0.417960344886783419761,
        0.4730935568360100744212,
        0.5264321628773558002446,
        0.5777738314082511021102,
        0.6269238058941064650172,
        0.6736956436465572117127,
        0.7179119230644419217517,
        0.759404916654707132483,
        0.798017227280239503333,
        0.8336023852211194846165,
        0.8660254037844386467637,
        0.895163291355062322067,
        0.9209055179449536255994,
        0.943154434471277464057,
        0.9618256431728190704088,
        0.9768483177596007116214,
        0.988165472081259413762,
        0.9957341762950345218712,
        0.999525719713365874666};
    ///Chebyshev 1st
    double cA51W [] = {0.06159985595274104389,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.06159985595274104389142,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.06159985595274104389142,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.0615998559527410438914,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.061599855952741043891,
        0.0615998559527410438914,
        0.06159985595274104389,
        0.061599855952741043891};
    
    double la96X[] = {-1,
        -0.9991951753769260433267,
        -0.9973028330170082864579,
        -0.9943310519906122807996,
        -0.9902832781543304384612,
        -0.985163932126614011137,
        -0.978978564977784333326,
        -0.9717338739890572962493,
        -0.963437700287926497098,
        -0.954099021820540160098,
        -0.9437279441621886693202,
        -0.9323356897992662558288,
        -0.9199345860850416819375,
        -0.9065380519498901115298,
        -0.8921605834072087892397,
        -0.8768177378823579484025,
        -0.8605261173870329817875,
        -0.843303350559981906212,
        -0.82516807359491829583,
        -0.8061399100770423635855,
        -0.7862394497504294801806,
        -0.7654882262395207819546,
        -0.743908693748980098705,
        -0.72152420276722755296,
        -0.698358974800002783981,
        -0.6744380761613385550464,
        -0.649787390850331782202,
        -0.624433592543079489309,
        -0.598404115730098918316,
        -0.5717271260304718573805,
        -0.5444314897148415132843,
        -0.5165467424702445613102,
        -0.4881030574405801606775,
        -0.4591312125773006657669,
        -0.4296625573356545310336,
        -0.399728978752519617574,
        -0.369362866942533944599,
        -0.3385970800498601307719,
        -0.307464908693508633376,
        -0.2760000399446927634894,
        -0.244236520875194727907,
        -0.2122087217161860671716,
        -0.1799512986673673153952,
        -0.147499156396670041051,
        -0.114887410271099226071,
        -0.08215134835958483863319,
        -0.04932639324895813657206,
        -0.0164480637143704351006,
        0.0164480637143704351006,
        0.0493263932489581365721,
        0.0821513483595848386332,
        0.1148874102710992260705,
        0.147499156396670041051,
        0.1799512986673673153952,
        0.2122087217161860671716,
        0.2442365208751947279066,
        0.2760000399446927634894,
        0.307464908693508633376,
        0.338597080049860130772,
        0.3693628669425339445992,
        0.399728978752519617574,
        0.4296625573356545310336,
        0.4591312125773006657669,
        0.488103057440580160678,
        0.5165467424702445613102,
        0.544431489714841513284,
        0.5717271260304718573805,
        0.5984041157300989183162,
        0.6244335925430794893093,
        0.6497873908503317822017,
        0.6744380761613385550464,
        0.698358974800002783981,
        0.7215242027672275529604,
        0.743908693748980098705,
        0.765488226239520781955,
        0.7862394497504294801806,
        0.806139910077042363586,
        0.82516807359491829583,
        0.843303350559981906212,
        0.8605261173870329817875,
        0.8768177378823579484025,
        0.8921605834072087892397,
        0.9065380519498901115298,
        0.9199345860850416819375,
        0.932335689799266255829,
        0.9437279441621886693202,
        0.9540990218205401600975,
        0.9634377002879264970977,
        0.9717338739890572962493,
        0.9789785649777843333264,
        0.9851639321266140111372,
        0.9902832781543304384612,
        0.9943310519906122807996,
        0.9973028330170082864579,
        0.9991951753769260433267,
        1};
    
    double la96W[] ={2.192982456140350877193E-4,
        0.001351534905655567239,
        0.002432578603010584801,
        0.00351042237502451777821,
        0.004584389784779426443,
        0.0056533772363714560586,
        0.0067162407897201923409,
        0.00777183421191470895504,
        0.0088190167116770609691,
        0.00985665578151741140719,
        0.0108836289198820282255,
        0.011898825025498477896,
        0.0129011456729245848214,
        0.01388950633390918365258,
        0.014862837566750324613,
        0.015820086181631326707,
        0.016760216384641604499,
        0.0176822109010640166545,
        0.0185850720775976758169,
        0.01946782296277537045861,
        0.0203295083646475577094,
        0.0211691958847220091305,
        0.0219859769271168563597,
        0.0227789676818802568533,
        0.0235473100814400702819,
        0.0242901727291656332337,
        0.0250067517990476829368,
        0.0256962719055299251552,
        0.0263579869425556559741,
        0.02699118089092463744,
        0.0275951685930887291095,
        0.028169296494549358149,
        0.0287129433510556117802,
        0.029225520900838443954,
        0.0297064745011541160216,
        0.030155283728448467571,
        0.030571462941492877081,
        0.0309545618068827668081,
        0.0313041657863301804524,
        0.031619896585223265455,
        0.031901412561967375625,
        0.032148409097664925898,
        0.032360618925734031546,
        0.032537812421109301242,
        0.032679797848711879112,
        0.032786421570919897236,
        0.0328575682138148587855,
        0.0328931607920240746724,
        0.0328931607920240746724,
        0.0328575682138148587855,
        0.032786421570919897236,
        0.032679797848711879112,
        0.032537812421109301242,
        0.0323606189257340315458,
        0.032148409097664925898,
        0.031901412561967375625,
        0.031619896585223265455,
        0.0313041657863301804524,
        0.0309545618068827668081,
        0.030571462941492877081,
        0.030155283728448467571,
        0.029706474501154116022,
        0.029225520900838443954,
        0.02871294335105561178,
        0.028169296494549358149,
        0.027595168593088729109,
        0.02699118089092463744,
        0.0263579869425556559741,
        0.0256962719055299251552,
        0.0250067517990476829368,
        0.024290172729165633234,
        0.023547310081440070282,
        0.0227789676818802568533,
        0.02198597692711685636,
        0.0211691958847220091305,
        0.0203295083646475577094,
        0.019467822962775370459,
        0.018585072077597675817,
        0.0176822109010640166545,
        0.0167602163846416044985,
        0.015820086181631326707,
        0.0148628375667503246134,
        0.013889506333909183653,
        0.0129011456729245848214,
        0.0118988250254984778963,
        0.0108836289198820282255,
        0.0098566557815174114072,
        0.008819016711677060969,
        0.007771834211914708955,
        0.0067162407897201923409,
        0.0056533772363714560586,
        0.0045843897847794264433,
        0.0035104223750245177782,
        0.00243257860301058480139,
        0.001351534905655567239,
        2.192982456140350877193E-4};
    
    
    double gk99X [] ={-0.999804199685638727995,
        -0.9988201506066353793618,
        -0.996819814299826469401,
        -0.9937886619441677907601,
        -0.9897642384140644710632,
        -0.984757895914213004359,
        -0.9787573030312066845299,
        -0.97176220090155538014,
        -0.9637900181363554282611,
        -0.954853658674137233555,
        -0.944955059221329473156,
        -0.934100294755810149059,
        -0.922305475453936168755,
        -0.909585655828073285213,
        -0.8959496245835934207352,
        -0.881408445573008910037,
        -0.8659800043151457264443,
        -0.8496821198441657010349,
        -0.832528501487460168517,
        -0.8145344273598554315395,
        -0.7957203207625248381361,
        -0.7761068943454466350181,
        -0.7557118903695143082457,
        -0.734554254237402696214,
        -0.7126570667050088308474,
        -0.6900438244251321135048,
        -0.666735700841571667866,
        -0.642754832419237664057,
        -0.6181268178008792991612,
        -0.5928776941089007124559,
        -0.5670315494953917328631,
        -0.5406132469917260665582,
        -0.5136506284017343823111,
        -0.486171941452492042177,
        -0.4582036915390298548496,
        -0.4297729933415765246586,
        -0.4009095739292798809373,
        -0.3716435012622848888637,
        -0.3420031959918559601078,
        -0.3120175321197487622079,
        -0.2817177082410294178775,
        -0.2511351786125772735072,
        -0.2202997655098053353243,
        -0.1892415924618135864853,
        -0.157992877664368358666,
        -0.126585997269672051068,
        -0.09505164998612337566,
        -0.0634206849826867860288,
        -0.03172586345907315363082,
        0.0,
        0.03172586345907315363082,
        0.06342068498268678602884,
        0.09505164998612337566,
        0.126585997269672051068,
        0.157992877664368358666,
        0.189241592461813586485,
        0.2202997655098053353243,
        0.2511351786125772735072,
        0.2817177082410294178775,
        0.3120175321197487622079,
        0.3420031959918559601078,
        0.3716435012622848888637,
        0.4009095739292798809373,
        0.4297729933415765246586,
        0.4582036915390298548496,
        0.486171941452492042177,
        0.5136506284017343823111,
        0.540613246991726066558,
        0.567031549495391732863,
        0.5928776941089007124559,
        0.618126817800879299161,
        0.6427548324192376640569,
        0.666735700841571667866,
        0.6900438244251321135048,
        0.712657066705008830847,
        0.7345542542374026962137,
        0.7557118903695143082457,
        0.7761068943454466350181,
        0.7957203207625248381361,
        0.81453442735985543154,
        0.8325285014874601685173,
        0.8496821198441657010349,
        0.8659800043151457264443,
        0.881408445573008910037,
        0.8959496245835934207352,
        0.909585655828073285213,
        0.9223054754539361687554,
        0.934100294755810149059,
        0.944955059221329473156,
        0.9548536586741372335552,
        0.9637900181363554282611,
        0.97176220090155538014,
        0.97875730303120668453,
        0.9847578959142130043593,
        0.9897642384140644710632,
        0.9937886619441677907601,
        0.9968198142998264694013,
        0.9988201506066353793618,
        0.999804199685638727995};
    
    double gk99W[] = {0.0005274769683783323143,
        0.0014779639281743620209,
        0.0025218765731496496845,
        0.0035329557014832599892,
        0.0045141331625998620836,
        0.005501420399338078204,
        0.0064998725321664845168,
        0.0074869102764140445198,
        0.0084551856397750456701,
        0.0094175722296862066762,
        0.010378732924116607707,
        0.0113278438578780228795,
        0.0122591748799473589077,
        0.0131792068212079366057,
        0.0140911110472705440377,
        0.0149880989346802956593,
        0.01586572369887289313,
        0.016727898553777318682,
        0.017576872641244826238,
        0.0184077538519825820281,
        0.0192169329826556442117,
        0.0200070643859274929265,
        0.0207798535198561693337,
        0.0215314818077816867538,
        0.022258913930129946636,
        0.0229641216311680166298,
        0.0236484943738631350276,
        0.02430890292981194970869,
        0.0249427312116380137806,
        0.0255515676298983967962,
        0.0261366295727170561997,
        0.0266952731071580377427,
        0.027225205808796711996,
        0.0277278075508688728381,
        0.0282042205700292005214,
        0.0286521667109019998496,
        0.0290696140121504756931,
        0.0294578454056420734076,
        0.0298179973237107521896,
        0.030148081066799933145,
        0.0304462797396858877386,
        0.030713855857739083392,
        0.030951992615566392528,
        0.03115893749659741587,
        0.0313330525912310597589,
        0.03147563582699890351852,
        0.031587959458685973161,
        0.03166846605661171584462,
        0.031715664503973344041,
        0.0317309313985218944091,
        0.031715664503973344041,
        0.0316684660566117158446,
        0.031587959458685973161,
        0.031475635826998903519,
        0.0313330525912310597589,
        0.03115893749659741587,
        0.03095199261556639252752,
        0.030713855857739083392,
        0.0304462797396858877386,
        0.030148081066799933145,
        0.0298179973237107521896,
        0.029457845405642073408,
        0.0290696140121504756931,
        0.0286521667109019998496,
        0.02820422057002920052136,
        0.027727807550868872838,
        0.027225205808796711996,
        0.026695273107158037743,
        0.0261366295727170561997,
        0.025551567629898396796,
        0.0249427312116380137806,
        0.0243089029298119497087,
        0.0236484943738631350276,
        0.02296412163116801663,
        0.02225891393012994663599,
        0.0215314818077816867538,
        0.020779853519856169334,
        0.0200070643859274929265,
        0.0192169329826556442117,
        0.0184077538519825820281,
        0.017576872641244826238,
        0.016727898553777318682,
        0.01586572369887289313,
        0.014988098934680295659,
        0.0140911110472705440377,
        0.0131792068212079366057,
        0.012259174879947358908,
        0.0113278438578780228795,
        0.010378732924116607707,
        0.0094175722296862066762,
        0.0084551856397750456701,
        0.0074869102764140445198,
        0.0064998725321664845168,
        0.005501420399338078204,
        0.0045141331625998620836,
        0.0035329557014832599892,
        0.002521876573149649685,
        0.0014779639281743620209,
        0.00052747696837833231426};
    
    double he98X[]= {-13.3344618199431538585,
        -12.75074072250337404795,
        -12.26902499946790279665,
        -11.84031761061562603291,
        -11.44591148464280386928,
        -11.07617128730026256197,
        -10.72531983816797100433,
        -10.38955210246585906299,
        -10.06619543858922555079,
        -9.75328223045455323894,
        -9.449310879974327341335,
        -9.15310237453911956936,
        -8.86370935324198104376,
        -8.58035586099743585986,
        -8.302395964605610939682,
        -8.029284452442398742078,
        -7.76055554951123389537,
        -7.49580710939752645596,
        -7.23468864566545524384,
        -6.97689211557936602074,
        -6.722144715993879426692,
        -6.47020317615234145962,
        -6.220849181529241495862,
        -5.973885664289001648428,
        -5.72913376617139756119,
        -5.486430329116947243449,
        -5.245625804399271387618,
        -5.006582496796805064715,
        -4.769173079312691503251,
        -4.533279328100446204636,
        -4.298791037921933522074,
        -4.065605086593353722815,
        -3.83362462312876049926,
        -3.602758359144718589345,
        -3.372919946888462977448,
        -3.14402743024742499877,
        -2.916002757476634268321,
        -2.688771346281392686675,
        -2.46226169342046945364,
        -2.236405022229358767821,
        -2.011134962464637376126,
        -1.786387257685927001415,
        -1.562099496057621363534,
        -1.338210860996563085257,
        -1.114661898536273775965,
        -0.8913942986404006336546,
        -0.6683506879912633312313,
        -0.4454744320143341589939,
        -0.22270944408436804682,
        0,
        0.2227094440843680468202,
        0.4454744320143341589939,
        0.6683506879912633312313,
        0.891394298640400633655,
        1.114661898536273775965,
        1.338210860996563085257,
        1.562099496057621363534,
        1.786387257685927001415,
        2.011134962464637376126,
        2.236405022229358767821,
        2.46226169342046945364,
        2.688771346281392686675,
        2.916002757476634268321,
        3.144027430247424998769,
        3.372919946888462977448,
        3.602758359144718589345,
        3.833624623128760499256,
        4.065605086593353722815,
        4.298791037921933522074,
        4.533279328100446204636,
        4.769173079312691503251,
        5.006582496796805064715,
        5.245625804399271387618,
        5.486430329116947243449,
        5.72913376617139756119,
        5.973885664289001648428,
        6.220849181529241495862,
        6.47020317615234145962,
        6.722144715993879426692,
        6.97689211557936602074,
        7.234688645665455243844,
        7.49580710939752645596,
        7.760555549511233895371,
        8.029284452442398742078,
        8.302395964605610939682,
        8.58035586099743585986,
        8.86370935324198104376,
        9.15310237453911956936,
        9.449310879974327341335,
        9.75328223045455323894,
        10.06619543858922555079,
        10.38955210246585906299,
        10.72531983816797100433,
        11.07617128730026256197,
        11.4459114846428038693,
        11.84031761061562603291,
        12.26902499946790279665,
        12.75074072250337404795,
        13.33446181994315385852};
    
    double he98W[] = {0.675529338234794777,
        0.5194423852368051259,
        0.4508288762108832614,
        0.4094677188322498383,
        0.3808799537126828077,
        0.3595357207010613123,
        0.34278855676613559807,
        0.32918568548221520298,
        0.3178517902474171195,
        0.30822259499871209382,
        0.29991514056505216206,
        0.2926587861109895599,
        0.28625590789811076932,
        0.28055825304183459228,
        0.27545205940863081479,
        0.27084833438454826619,
        0.266676298915512194746,
        0.26287884382938245758,
        0.25940930522033376674,
        0.2562291278755198725,
        0.25330614076990745649,
        0.25061326329612081219,
        0.24812752030984269856,
        0.24582928231409925773,
        0.24370167227933208038,
        0.24173009750517096921,
        0.239901876497616933885,
        0.23820593888235827502,
        0.236632582058957081801,
        0.23517327237232510342,
        0.233820481532637958302,
        0.23256755118488962508,
        0.231408580140911843691,
        0.230338329996088927225,
        0.22935214576945277674,
        0.22844588890670181427,
        0.227615880526339902787,
        0.226858853209660481463,
        0.22617190996500663855,
        0.2255524892572412033208,
        0.224998335200763305304,
        0.224507472180804967741,
        0.224078183302298161977,
        0.223708992175323367616,
        0.223398647636434786041,
        0.223146111080206779564,
        0.2229505461384643895921,
        0.222811310498476310126,
        0.2227279496980228838902,
        0.222700192776447592385,
        0.2227279496980228838902,
        0.222811310498476310126,
        0.222950546138464389592,
        0.223146111080206779564,
        0.223398647636434786041,
        0.223708992175323367616,
        0.224078183302298161977,
        0.224507472180804967741,
        0.224998335200763305304,
        0.225552489257241203321,
        0.22617190996500663855,
        0.22685885320966048146,
        0.227615880526339902787,
        0.22844588890670181427,
        0.22935214576945277674,
        0.23033832999608892723,
        0.23140858014091184369,
        0.232567551184889625077,
        0.2338204815326379583,
        0.235173272372325103418,
        0.2366325820589570818,
        0.23820593888235827502,
        0.239901876497616933885,
        0.24173009750517096921,
        0.24370167227933208038,
        0.24582928231409925773,
        0.24812752030984269856,
        0.250613263296120812194,
        0.253306140769907456489,
        0.2562291278755198725,
        0.25940930522033376674,
        0.26287884382938245758,
        0.266676298915512194746,
        0.27084833438454826619,
        0.27545205940863081479,
        0.28055825304183459228,
        0.28625590789811076932,
        0.2926587861109895599,
        0.29991514056505216206,
        0.30822259499871209382,
        0.31785179024741711946,
        0.329185685482215203,
        0.3427885567661355981,
        0.3595357207010613123,
        0.38087995371268280768,
        0.40946771883224983827,
        0.4508288762108832614,
        0.5194423852368051259,
        0.6755293382347947774};
    
    double la99X [] = {-1,
        -0.9992434488114229351022,
        -0.9974645612720409879187,
        -0.9946708163880982960961,
        -0.990865272230294312895,
        -0.9860518378741464147823,
        -0.9802354202679529513612,
        -0.9734219397008407490587,
        -0.9656183283699988435022,
        -0.9568325246989801560959,
        -0.9470734657566868682497,
        -0.9363510783707391398238,
        -0.9246762691235478707544,
        -0.912060913304824077264,
        -0.8985178428569909128727,
        -0.8840608333367167241446,
        -0.8687045899109525250145,
        -0.8524647324042628389538,
        -0.8353577794139909255225,
        -0.8174011315101445569656,
        -0.7986130535375052779395,
        -0.7790126560382066880758,
        -0.7586198758138259174845,
        -0.7374554556468519440804,
        -0.7155409232022161067443,
        -0.6928985691303837254369,
        -0.6695514243943050421778,
        -0.6455232368433049265956,
        -0.620838447057751395773,
        -0.595522163489081156226,
        -0.569600136920474693245,
        -0.5430987342741627826675,
        -0.5160449117920097272658,
        -0.4884661876166552853881,
        -0.4603906138011064082351,
        -0.4318467477752508429226,
        -0.4028636232983167521467,
        -0.3734707209268251532674,
        -0.3436979380280746355478,
        -0.3135755583696599571001,
        -0.283134221315957271461,
        -0.252404890662908441091,
        -0.221418823142804749122,
        -0.1902075366311059430164,
        -0.1588027780876335899953,
        -0.1272364912647478836811,
        -0.0955407842153540378783,
        -0.0637478966337879945382,
        -0.031890167062801150697,
        0,
        0.0318901670628011506972,
        0.0637478966337879945382,
        0.0955407842153540378783,
        0.127236491264747883681,
        0.1588027780876335899953,
        0.1902075366311059430164,
        0.221418823142804749122,
        0.2524048906629084410908,
        0.283134221315957271461,
        0.3135755583696599571,
        0.3436979380280746355478,
        0.3734707209268251532674,
        0.402863623298316752147,
        0.431846747775250842923,
        0.4603906138011064082351,
        0.4884661876166552853881,
        0.5160449117920097272658,
        0.5430987342741627826675,
        0.5696001369204746932449,
        0.5955221634890811562261,
        0.6208384470577513957728,
        0.6455232368433049265956,
        0.6695514243943050421778,
        0.6928985691303837254369,
        0.7155409232022161067443,
        0.7374554556468519440804,
        0.7586198758138259174845,
        0.7790126560382066880758,
        0.7986130535375052779395,
        0.8174011315101445569656,
        0.8353577794139909255225,
        0.8524647324042628389538,
        0.8687045899109525250145,
        0.8840608333367167241446,
        0.8985178428569909128727,
        0.912060913304824077264,
        0.9246762691235478707544,
        0.9363510783707391398238,
        0.9470734657566868682497,
        0.9568325246989801560959,
        0.9656183283699988435022,
        0.9734219397008407490587,
        0.9802354202679529513612,
        0.9860518378741464147823,
        0.990865272230294312895,
        0.9946708163880982960961,
        0.9974645612720409879187,
        0.9992434488114229351022,
        1};
    
    double la99W[] ={2.061430632859204287776E-4,
        0.001270479977782297294,
        0.002286777395342568412,
        0.003300215141163138842,
        0.004310222852065934661,
        0.005315828181882797192,
        0.006316020274268851382,
        0.007309785395202577542,
        0.008296114068458742968,
        0.0092740036136167950078,
        0.0102424596328152810673,
        0.0112004971911409648705,
        0.012147141887327426552,
        0.0130814308756991815842,
        0.0140024138604168739314,
        0.0149091540697226743056,
        0.01580072921292428219806,
        0.0166762324208543477524,
        0.01753477316967991631,
        0.0183754781875468653378,
        0.01919749234336365664,
        0.019999979516945885665,
        0.0207821234497084740578,
        0.02154312857508267836276,
        0.02228222082783899937587,
        0.0229986484315087803676,
        0.0236916826631137208552,
        0.024360618594432036277,
        0.0250047758090516205355,
        0.02562349909448376771805,
        0.0262161591086354482214,
        0.0267821530199636026648,
        0.0273209051206612753058,
        0.0278318674122525598269,
        0.0283145201630012021845,
        0.0287683724365662406774,
        0.0291929625913672147722,
        0.029587858750151199508,
        0.0299526592392841829573,
        0.03028699299732006384907,
        0.03059051995243176992,
        0.0308629313683206504025,
        0.0311039501582523442447,
        0.0313133311668997351963,
        0.0314908614197063419711,
        0.031636360339516522211,
        0.031749679930252158921,
        0.0318307049274490131517,
        0.0318793529154996325817,
        0.031895574411483567878,
        0.031879352915499632582,
        0.0318307049274490131517,
        0.031749679930252158921,
        0.031636360339516522211,
        0.031490861419706341971,
        0.031313331166899735196,
        0.0311039501582523442447,
        0.030862931368320650403,
        0.0305905199524317699196,
        0.0302869929973200638491,
        0.0299526592392841829573,
        0.029587858750151199508,
        0.0291929625913672147722,
        0.028768372436566240677,
        0.028314520163001202185,
        0.027831867412252559827,
        0.0273209051206612753058,
        0.026782153019963602665,
        0.0262161591086354482214,
        0.0256234990944837677181,
        0.0250047758090516205355,
        0.024360618594432036277,
        0.023691682663113720855,
        0.0229986484315087803676,
        0.0222822208278389993759,
        0.021543128575082678363,
        0.020782123449708474058,
        0.0199999795169458856651,
        0.0191974923433636566399,
        0.0183754781875468653378,
        0.01753477316967991631,
        0.0166762324208543477524,
        0.015800729212924282198,
        0.014909154069722674306,
        0.01400241386041687393144,
        0.0130814308756991815842,
        0.0121471418873274265525,
        0.0112004971911409648705,
        0.0102424596328152810673,
        0.009274003613616795008,
        0.0082961140684587429683,
        0.007309785395202577542,
        0.0063160202742688513816,
        0.005315828181882797192,
        0.0043102228520659346608,
        0.0033002151411631388418,
        0.002286777395342568412,
        0.001270479977782297294,
        2.061430632859204287776E-4};
    
    double rla217X[] = {-1., -0.998455, -0.995346, -0.991582, -0.987817, -0.984708, \
        -0.983163, -0.980054, -0.973798, -0.966222, -0.958646, -0.95239, \
        -0.949281, -0.945516, -0.93794, -0.928765, -0.919589, -0.912013, \
        -0.908248, -0.904483, -0.896907, -0.887732, -0.878557, -0.87098, \
        -0.867216, -0.864107, -0.857851, -0.850275, -0.842698, -0.836442, \
        -0.833333, -0.831789, -0.82868, -0.824915, -0.82115, -0.818041, \
        -0.816497, -0.813388, -0.807132, -0.799555, -0.791979, -0.785723, \
        -0.782614, -0.776358, -0.763768, -0.748522, -0.733275, -0.720685, \
        -0.714429, -0.706853, -0.691606, -0.673142, -0.654678, -0.639431, \
        -0.631855, -0.624279, -0.609032, -0.590568, -0.572104, -0.556857, \
        -0.549281, -0.543025, -0.530435, -0.515188, -0.499942, -0.487352, \
        -0.481096, -0.477987, -0.471731, -0.464155, -0.456578, -0.450322, \
        -0.447214, -0.443449, -0.435872, -0.426697, -0.417522, -0.409946, \
        -0.406181, -0.398605, -0.383358, -0.364894, -0.34643, -0.331183, \
        -0.323607, -0.314432, -0.295967, -0.273607, -0.251246, -0.232782, \
        -0.223607, -0.214432, -0.195967, -0.173607, -0.151246, -0.132782, \
        -0.123607, -0.11603, -0.100784, -0.0823197, -0.0638556, -0.0486089, \
        -0.0410326, -0.0372678, -0.0296915, -0.0205163, -0.0113411, \
        -0.00376481, 0., 0.00376481, 0.0113411, 0.0205163, 0.0296915, \
        0.0372678, 0.0410326, 0.0486089, 0.0638556, 0.0823197, 0.100784, \
        0.11603, 0.123607, 0.132782, 0.151246, 0.173607, 0.195967, 0.214432, \
        0.223607, 0.232782, 0.251246, 0.273607, 0.295967, 0.314432, 0.323607, \
        0.331183, 0.34643, 0.364894, 0.383358, 0.398605, 0.406181, 0.409946, \
        0.417522, 0.426697, 0.435872, 0.443449, 0.447214, 0.450322, 0.456578, \
        0.464155, 0.471731, 0.477987, 0.481096, 0.487352, 0.499942, 0.515188, \
        0.530435, 0.543025, 0.549281, 0.556857, 0.572104, 0.590568, 0.609032, \
        0.624279, 0.631855, 0.639431, 0.654678, 0.673142, 0.691606, 0.706853, \
        0.714429, 0.720685, 0.733275, 0.748522, 0.763768, 0.776358, 0.782614, \
        0.785723, 0.791979, 0.799555, 0.807132, 0.813388, 0.816497, 0.818041, \
        0.82115, 0.824915, 0.82868, 0.831789, 0.833333, 0.836442, 0.842698, \
        0.850275, 0.857851, 0.864107, 0.867216, 0.87098, 0.878557, 0.887732, \
        0.896907, 0.904483, 0.908248, 0.912013, 0.919589, 0.928765, 0.93794, \
        0.945516, 0.949281, 0.95239, 0.958646, 0.966222, 0.973798, 0.980054, \
        0.983163, 0.984708, 0.987817, 0.991582, 0.995346, 0.998455, 1.};
        
        double rla217W[] = {0.000440963, 0.00247397, 0.00357924, 0.0038484, 0.00357924, \
            0.00247397, 0.00132836, 0.00497863, 0.00720288, 0.00774454, \
            0.00720288, 0.00497863, 0.00196206, 0.00602928, 0.00872292, \
            0.00937888, 0.00872292, 0.00602928, 0.00214933, 0.00602928, \
            0.00872292, 0.00937888, 0.00872292, 0.00602928, 0.00196206, \
            0.00497863, 0.00720288, 0.00774454, 0.00720288, 0.00497863, \
            0.00132836, 0.00247397, 0.00357924, 0.0038484, 0.00357924, \
            0.00247397, 0.00132836, 0.00497863, 0.00720288, 0.00774454, \
            0.00720288, 0.00497863, 0.00267319, 0.010019, 0.0144951, 0.0155851, \
            0.0144951, 0.010019, 0.00394845, 0.0121333, 0.017554, 0.0188741, \
            0.017554, 0.0121333, 0.00432531, 0.0121333, 0.017554, 0.0188741, \
            0.017554, 0.0121333, 0.00394845, 0.010019, 0.0144951, 0.0155851, \
            0.0144951, 0.010019, 0.00267319, 0.00497863, 0.00720288, 0.00774454, \
            0.00720288, 0.00497863, 0.00196206, 0.00602928, 0.00872292, \
            0.00937888, 0.00872292, 0.00602928, 0.00323732, 0.0121333, 0.017554, \
            0.0188741, 0.017554, 0.0121333, 0.0047817, 0.0146939, 0.0212585, \
            0.0228571, 0.0212585, 0.0146939, 0.0052381, 0.0146939, 0.0212585, \
            0.0228571, 0.0212585, 0.0146939, 0.0047817, 0.0121333, 0.017554, \
            0.0188741, 0.017554, 0.0121333, 0.00323732, 0.00602928, 0.00872292, \
            0.00937888, 0.00872292, 0.00602928, 0.00214933, 0.00602928, \
            0.00872292, 0.00937888, 0.00872292, 0.00602928, 0.00323732, \
            0.0121333, 0.017554, 0.0188741, 0.017554, 0.0121333, 0.0047817, \
            0.0146939, 0.0212585, 0.0228571, 0.0212585, 0.0146939, 0.0052381, \
            0.0146939, 0.0212585, 0.0228571, 0.0212585, 0.0146939, 0.0047817, \
            0.0121333, 0.017554, 0.0188741, 0.017554, 0.0121333, 0.00323732, \
            0.00602928, 0.00872292, 0.00937888, 0.00872292, 0.00602928, \
            0.00196206, 0.00497863, 0.00720288, 0.00774454, 0.00720288, \
            0.00497863, 0.00267319, 0.010019, 0.0144951, 0.0155851, 0.0144951, \
            0.010019, 0.00394845, 0.0121333, 0.017554, 0.0188741, 0.017554, \
            0.0121333, 0.00432531, 0.0121333, 0.017554, 0.0188741, 0.017554, \
            0.0121333, 0.00394845, 0.010019, 0.0144951, 0.0155851, 0.0144951, \
            0.010019, 0.00267319, 0.00497863, 0.00720288, 0.00774454, 0.00720288, \
            0.00497863, 0.00132836, 0.00247397, 0.00357924, 0.0038484, \
            0.00357924, 0.00247397, 0.00132836, 0.00497863, 0.00720288, \
            0.00774454, 0.00720288, 0.00497863, 0.00196206, 0.00602928, \
            0.00872292, 0.00937888, 0.00872292, 0.00602928, 0.00214933, \
            0.00602928, 0.00872292, 0.00937888, 0.00872292, 0.00602928, \
            0.00196206, 0.00497863, 0.00720288, 0.00774454, 0.00720288, \
            0.00497863, 0.00132836, 0.00247397, 0.00357924, 0.0038484, \
            0.00357924, 0.00247397, 0.000440963};
    
    
    double *gkX,*gkW;
    inta ngk=0;
    if ( pt ==1 ){
        gkX = gk1X;
        gkW = gk1W;
        ngk = 1;
    }
    if ( pt == 3 ){
        gkX = gk3X;
        gkW = gk3W;
        ngk = 3;
    }else
    if ( pt == 7 ) {
        gkX = gk7X;
        gkW = gk7W;
        ngk = 7;
    }else
    if ( pt == 9 ) {
        gkX = cB9X;
        gkW = cB9W;
        ngk = 9;
    }

        else if ( pt == 10 ){
            gkX = gk10X;
            gkW = gk10W;
            ngk = 10;
        
    }else if ( pt == 15 ){
        gkX = gk15X;
        gkW = gk15W;
        ngk = 15;
    }
    else
    if ( pt == 18 ) {
            gkX = cy18X;
            gkW = cy18W;
            ngk = 18;
    }else if ( pt == 34 ){
        gkX = la34X;
        gkW = la34W;
        ngk = 34;
    }else if ( pt == 35 ){
        gkX = gk35X;
        gkW = gk35W;
        ngk = 35;
    } else
        if ( pt == 36 ) {
                gkX = cB36X;
                gkW = cB36W;
            ngk = 36;
        }
        else
        if ( pt == 37 ) {
                gkX = rla37X;
                gkW = rla37W;
                ngk = 37;
        }
            else
            if ( pt == 48 ) {
                    gkX = la48X;
                    gkW = la48W;
                    ngk = 48;
                
            }else if ( pt == 49 ){
                gkX =gk49X;
                gkW = gk49W;
                ngk = 49;
            }else if ( pt == 50 ){
                gkX = cB50X;
                gkW = cB50W;
                ngk = 50;
            }else if ( pt == 51 ){
        gkX = cA51X;
        gkW = cA51W;
        ngk = 51;
    }else if ( pt == 96 ){
        gkX = la96X;
        gkW = la96W;
        ngk = 96;
    } else if ( pt == 98 ){
        gkX = he98X;
        gkW = he98W;
    }else if ( pt == 99 ){
        gkX = la99X;
        gkW = la99W;
        ngk = 99;
    }else if ( pt == 217 ){
        gkX = rla217X;
        gkW = rla217W;
        ngk = 217;
    }else {
        exit(0);
    }
    if ( truncate){
        if ( which )
            return 0.5*(1+gkX[ngk-1-nm]);
        else
            return 0.5*gkW[ngk-1-nm];//shift to interval [0,1]
    }else {
        // interval [-1,1]
        if ( which )
            return gkX[nm];
        else
            return gkW[nm];
    }
}


/**
 *Metric
 *
 *Ment to simplify quadrature, by inputing a metric and outputing an array
 *allocates X and W
 *free them after use.
 */
inta quadrature( metric_label metric, floata *X, floata* W){
    floata constant,g,x;
    inta beta,section=2,flagConstants=0,ngk;
    if ( metric.metric == interval )
        section = 0;
   else  if ( metric.metric == semiIndefinite)
        section = 1;
   else if ( metric.metric == dirac)
        section = 2;

    else if ( metric.metric == pureSemiIndefinite){
        section = 1;
        flagConstants = 1;
    }
    else if ( metric.metric == pureInterval){
        flagConstants = 1;
        section = 0;
    }
    else if ( metric.metric == pureWholeInterval ){
        flagConstants = 1;
        section = -1;
    }

    
    if ( section < 2 ){
        ngk = metric.fn.interval;
    }
    else {
        ngk = 1;
    }
    
    for ( beta = 0; beta < ngk ; beta++){//beta is an index.
        if (  section == 1 ){
            g = gaussQuad(ngk,beta,1,1);// [1, inf)
            constant = gaussQuad(ngk, beta, 0,1);
            
            x = ( g ) / (1. - g)+1 ;
            constant /= (1.-g)*(1.-g);
            
            
            x *=  metric.beta[0];
            constant *= metric.beta[0];
            if ( ! flagConstants )
                constant *= inverseLaplaceTransform(x,&metric.fn);
        } else if ( section == 0 ) {
            g = gaussQuad(ngk,beta,1,1);//interval [0,1]
            constant = gaussQuad(ngk, beta, 0,1);
            
            x = g;
            
            
            x *=  (metric.beta[1]-metric.beta[0]);
            constant *= (metric.beta[1]-metric.beta[0]);
            x += metric.beta[0];
            if ( ! flagConstants )
                constant *= inverseLaplaceTransform(x,&metric.fn);

        }else if ( section == -1 ) {
            g = gaussQuad(ngk,beta,1,0);//interval [-1,1]
            constant = gaussQuad(ngk, beta, 0,0);
            
            x = g;
            
            
            x *=  metric.beta[0];
            constant *= metric.beta[0];
            if ( ! flagConstants )
                constant *= inverseLaplaceTransform(x,&metric.fn);

        }
        else {
            x = metric.beta[0];// value;
            constant = 1;
        }
        X[beta] = x;
        W[beta] = constant;
    }
    return ngk;
}

/**
 *building quantum operators for oneBody and twoBody interactions
 */
inta separateInteraction(   sinc_label *f,double scalar, double * position,inta invert,inta act,  blockType bl, division load,  metric_label metric,  spinType cmpl,inta overline,   division basis ,inta * particle1,  bodyType body,inta embed){
      genusType hidden;
      sinc_label f1 = *f;
      division currLoop, currChain,newLabel;
    double adjustOne = 1.0;
    double oneL,twoL;
    inta perm[7],op[7];
    
    
    {
          division li = load;
        while ( f1.name[li].chainNext != nullName)
            li =f1.name[li].chainNext;
        currChain = li;
    }
    if ( metric.fn.fn == nullFunction){
        printf("null func\n");
        return 0;
    }
    inta n1[SPACE];
    length1(f1,n1);
    
    inta I1,space,I2,N1;
    floata x;
    
    floata *Xbeta = NULL, *Wbeta = NULL;
    Xbeta = malloc(metric.fn.interval *sizeof(floata));
    Wbeta = malloc(metric.fn.interval *sizeof(floata));
    inta si,beta, nbeta = quadrature(metric, Xbeta, Wbeta);

    for ( beta = 0; beta < nbeta ; beta++){//beta is an index.
        tClear(f1,eikonBuffer);
        zero(f1,eikonBuffer,0);
        inta invertSign;
    
        newLabel = anotherLabel(f,0,nada);
        f1.name[currChain].chainNext = newLabel;
        f1.name[newLabel].species = eikon;
        ///all equal-beta chained Ops will multiply on each beta index. i.e. H2+
        currChain = newLabel;
        currLoop = currChain;
        for ( hidden = eikonDiagonal ; hidden <= eikonDiagonal + imin(body,metric.fn.contr);hidden++ )
            {
                double oneOri,twoOri;
                invertSign = 1;
                x = Xbeta[beta];
                
            for ( space = 0 ;space < SPACE  ; space++)
                if ( f1.canon[space].body != nada )
                    if ( f1.canon[space].label == particle1[0] )
                {
                    //printf("space-%d position %f\n",space,position[f1.canon[space].space]);
                    if ( body == one ){
                        commandSA(f1.canon[space].body,act,tv1 , bl, perm, op);

                            oneL = f1.canon[space].particle[op[0]+1].lattice;
                            oneOri = f1.canon[space].particle[op[0]+1].origin;
                            ///position of left edge...

                            double * te = streams(f1, eikonBuffer, 0, space);
                            N1 = n1[space];

                                for ( si = 0 ; si < N1; si++){
                                        I1 = si;//
                                    if ( f1.canon[space].basis == SincBasisElement)
                                        te[si] = momentumIntegralInTrain(x*oneL, ((I1*oneL+oneOri)-position[f1.canon[space].space])/oneL,1, hidden, body);
                                    if ( f1.canon[space].basis == PeriodicSincBasisElement)
                                        te[si] = PeriodicMomentumIntegralInTrain(x*oneL, (I1*oneL+oneOri),oneL, position[f1.canon[space].space], hidden, N1, body);

                                    if ( invertSign  )
                                            te[si] *= scalar*Wbeta[beta];
                                    
                                    if ( alloc(f1, eikonBuffer, space) < si ){
                                        printf("creation of oneBody, somehow allocations of vectors are too small. %d\n",newLabel);
                                        exit(0);
                                    }

                                }

                        
                        
                        
                    }else
                    ///conditional body 2
                    if ( body == two ){
                        commandSA(f1.canon[space].body, f1.name[newLabel].space[space].act,e12 , bl, perm, op);
                        oneL = f1.canon[space].particle[op[0]+1].lattice*adjustOne;
                        oneOri = f1.canon[space].particle[op[0]+1].origin*adjustOne;
                        twoL = f1.canon[space].particle[op[1]+1].lattice;
                        twoOri = f1.canon[space].particle[op[1]+1].origin;
                        
                        N1 = n1[space];


                            
                    double * te = streams(f1, eikonBuffer, 0, space);

                                si = 0;
                                for ( I2 = 0; I2 < N1; I2++){
                                    for ( I1 = 0 ; I1 < N1; I1++)
                                     {
                                        if ( f1.canon[space].basis == SincBasisElement)
                                            te[si] = momentumIntegralInTrain(x*max(fabs(oneL),twoL), ((oneL*I1+oneOri)-(twoL*I2+twoOri))/max(fabs(oneL),twoL),1, hidden, body);
                                        if ( f1.canon[space].basis == PeriodicSincBasisElement)
                                            te[si] = PeriodicMomentumIntegralInTrain(x*oneL, ((oneL*I1+oneOri)-(twoL*I2+twoOri)),oneL,0, hidden, N1, body);
                                         
                                         if ( invertSign ){
                                             te[si] *= scalar*Wbeta[beta];
                                         }
                                             
                                         si++;
                                         if ( alloc(f1, eikonBuffer, space) < si ){
                                             printf("creation of twoBody, somehow allocations of vectors are too small. %d\n",newLabel);
                                             exit(0);
                                         }

                                     }
                                }
                                    if ( alloc(f1, eikonBuffer, space) < si ){
                                        printf("creation of twoBody, somehow allocations of vectors are too small. %d\n",newLabel);
                                        exit(0);
                                    }
                            }
                    invertSign = 0;

                }
                
                
            newLabel = anotherLabel(f,all,body);
            for ( space = 0 ;space < SPACE  ; space++)
                if ( f1.canon[space].body != nada ){
                    f1.name[newLabel].space[space].act = act;
                    if ( f1.canon[space].label == particle1[0] ){
                        f1.name[newLabel].space[space].body = body;
                        f1.name[newLabel].space[space].block = bl;
                    }else{
                        f1.name[newLabel].space[space].block = id0;
                }
            }
            f1.name[eikonBuffer].Current[0]= 1;
            tEqua(f1, newLabel, 0, eikonBuffer, 0);
            f1.name[currLoop].loopNext = newLabel;
            f1.name[newLabel].species = hidden;
            currLoop = newLabel;
        }
    }
    
    return 0;
}

/**
 *building quantum operators for oneBody and twoBody interactions
 *
 */
inta splitInteraction( sinc_label *f,double scalar, double * position,inta invert,inta act,  blockType bl,  division load,  metric_label metric, spinType spin,momentumIntegralSpecs specs,  division basis ,inta *particle1 , bodyType body,inta embed);


/**
 *building quantum operators for oneBody and twoBody interactions
 *Novel inputs:
 *--shape of external field,i.e., flat , Sine , or Gaussian
 *--Novel metric on momentum integral as sufficient
 *---basically a split operator has all kinds of degrees of internal freedom, specifiy
 *
 */
inta periodicInteraction( sinc_label *f,double scalar, double * position,inta invert,inta act,  blockType bl, division load,  metric_label metric,  spinType spin, momentumIntegralSpecs specs,floata cellLength, division basis ,inta *particle1,  bodyType body);


/**
 *building quantum operators for oneBody and twoBody interactions
 *For GaussianSinc Basis
*/
//inta factoredInteraction(   sinc_label *f,double scalar, double * position,inta invert, blockType bl, double adjustOne,    division load,  metric_label metric,  spinType spin,  division basis ,inta particle1,  bodyType body,inta embed){
//      genusType hidden;
//      sinc_label f1 = *f;
//      division temp , currLoop, currChain,newLabel;
//
//    double oneL,twoL;
//    inta perm[7],op[7];
//
//    inta space1 = 0;
//    {
//        inta space;
//        for ( space = 0 ;space < SPACE  ; space++)
//            if ( f1.canon[space].body != nada )
//                if ( particle1 == f1.canon[space].label ){
//                    space1 = space;
//                    break;
//                }
//
//    }
//
//    {
//          division li = load;
//        while ( f1.name[li].chainNext != nullName)
//            li =f1.name[li].chainNext;
//        currChain = li;
//        temp = eikonBuffer;
//    }
//    if ( metric.fn.fn == nullFunction){
//        printf("null func\n");
//        return 0;
//    }
//    inta n1[SPACE];
//    length1(f1,n1);
//
//    inta beta,I1,space,N1;
//
//    double constant,x,g;
//
//    inta section=2,si,ngk, intv = metric.fn.interval,flagConstants=0;
//
//    if ( metric.metric == interval )
//        section = 0;
//    if ( metric.metric == semiIndefinite)
//        section = 1;
//    if ( metric.metric == dirac)
//        section = 2;
//
//    if ( metric.metric == pureSemiIndefinite){
//        section = 1;
//        flagConstants = 1;
//    }
//    if ( metric.metric == pureInterval){
//        flagConstants = 1;
//        section = 0;
//    }
//    if ( section < 2 ){
//        ngk = intv;
//    }
//    else {
//        ngk = 1;
//    }
//
//    for ( beta = 0; beta < ngk ; beta++){//beta is an index.
//        if ( section == 1 ){
//            g = gaussQuad(ngk,beta,1);// [1, inf)
//            constant = gaussQuad(ngk, beta, 0);
//
//            x = ( g ) / (1. - g)+1 ;
//            constant /= (1.-g)*(1.-g);
//
//
//            x *=  metric.beta[0];
//            constant *= metric.beta[0];
//            if ( ! flagConstants )
//                constant *= inverseLaplaceTransform(x,&metric.fn)*scalar;
//            else
//                constant = 1;
//        }else if ( section == 0 ) {
//            g = gaussQuad(ngk,beta,1);//interval [0,1]
//            constant = gaussQuad(ngk, beta, 0);
//
//            x = g;
//
//
//            x *=  (metric.beta[1]-metric.beta[0]);
//            constant *= (metric.beta[1]-metric.beta[0]);
//            x += metric.beta[0];
//            if ( ! flagConstants )
//                constant *= inverseLaplaceTransform(x,&metric.fn)*scalar;
//            else
//                constant = 1;
//
//        } else {
//            x = metric.beta[0];// value;
//            constant = scalar;
//        }
//
//        //x is beta.
//        inta invertSign;
//
//        newLabel = anotherLabel(f,0,nada);
//        f1.name[currChain].chainNext = newLabel;
//        f1.name[newLabel].species = eikon;
//        f1.name[newLabel].spinor = spin;
//
//        ///all equal-beta chained Ops will multiply on each beta index. i.e. H2+
//        currChain = newLabel;
//        currLoop = currChain;
//
//
//        for ( hidden = eikonDiagonal ; hidden <= eikonDiagonal + imin(body,metric.fn.contr);hidden++ )
//            {
//                inta momentumIndex,momentumLength, bodyIndex ;
//                momentumLength = 2*f1.canon[space1].count1Basis;
//                for ( momentumIndex = -momentumLength ;  momentumIndex <= momentumLength ; momentumIndex++)
//                    for ( bodyIndex = 0 ; bodyIndex < body ; bodyIndex++)
//                {
//
//
//                    double iL,oneOri,twoOri,grpL,iO;
//                    invertSign = 1;
//
//                for ( space = 0 ;space < SPACE  ; space++)
//                    if ( f1.canon[space].body != nada )
//                        if ( f1.canon[space].label == particle1 )
//                    {
//                    ///conditional body 2
//                        {
//                            commandSA(f1.canon[space].body, f1.name[newLabel].space[space].act,e12 , bl, perm, op);
//                            oneL = f1.canon[space].particle[op[0]+1].lattice*adjustOne;
//                            oneOri = f1.canon[space].particle[op[0]+1].origin*adjustOne;
//
//                            if ( body == two) {
//                                twoL = f1.canon[space].particle[op[1]+1].lattice;
//                                twoOri = f1.canon[space].particle[op[1]+1].origin;
//                            }else {
//                                twoL= 0.;
//                                twoOri = 0.;
//                            }
//                            if ( oneL > twoL ){
//                                grpL = fabs(oneL);
//                            }else {
//                                grpL = fabs(twoL);
//
//                            }
//                            N1 = n1[space];
//
//
//                            DCOMPLEX tc;
//                            double * te = streams(f1, temp, 0, space);
//                            double * tec = streams(f1, temp, 1, space);
//                            f1.name[eikonBuffer].Current[0] = 1;
//                            f1.name[eikonBuffer].Current[1] = 1;
//                            si = 0;
//                            for ( I1 = 0 ; I1 < N1; I1++)
//                                {
//
//                                             ///HERE,  assign a quadature pattern
//                                                 double momentum = (momentumIndex);
//                                                 if ( bodyIndex == 0){
//                                                     iL = oneL;
//                                                     iO = oneOri;
//                                                 }
//                                                 else{
//                                                     iL = twoL;
//                                                     iO = twoOri;
//                                                 }
//                                                 ///HERE somehow need to populate gamma-s
//                                                 ///ALSO NEED a Metric
//
//                                                 //tc = gaussianSincfourierIntegralInTrain(iL, <#double gammax#>, <#double x#>, <#double gammay#>, <#double y#>, si, momentum, hidden);
//                                                 te[si] = creal(tc);
//                                                 tec[si] = cimag(tc);
//
//                                                if ( invertSign && bodyIndex == 0 ){
//
//                                                    ///find a quadrature given
//                                                    ///momentumIndex
//                                                    ///
//                                                    double gaussianKernel = 1;
//
//                                                    ///multiply of Gaussian here one first particle.
//                                                    te[si] *= constant*gaussianKernel;
//                                                    tec[si] *= constant*gaussianKernel;
//                                                }
//
//                                             if ( isnan(te[si]))
//                                                 printf("%f\n",te[si]);
//                                             si++;
//                                             if ( alloc(f1, temp, space) < si ){
//                                                 printf("creation of twoBody, somehow allocations of vectors are too small. %d\n",newLabel);
//                                                 exit(0);
//                                             }
//
//                                    }
//                                }
//                    invertSign = 0;
//                }
//
//            newLabel = anotherLabel(f,particle1,body);
//            ///if this is the first of two entries
//            if ( f1.canon[space].basis == PeriodicSincBasisElement || f1.canon[space].basis == GaussianSincBasisElement )
//                if ( bodyIndex == 0 && body == two)
//                    f1.name[newLabel].multId = 1;
//            f1.name[newLabel].spinor = spin;
//            for ( space = 0 ;space < SPACE  ; space++)
//                if ( f1.canon[space].body != nada ){
//                    f1.name[newLabel].space[space].act = 1;
//                    if ( f1.canon[space].label == particle1 ){
//                        if ( f1.canon[space].basis == SincBasisElement )
//                            f1.name[newLabel].space[space].body = body;
//                        else
//                            f1.name[newLabel].space[space].body = one;
//                        if ( f1.canon[space].basis == SincBasisElement )
//                            f1.name[newLabel].space[space].block = bl;
//                        else if ( f1.canon[space].basis == PeriodicSincBasisElement ){
//                            switch( bl ){
//                                case e12:
//                                    if ( bodyIndex == 0 )
//                                        f1.name[newLabel].space[space].block= tv1;
//                                    else
//                                        f1.name[newLabel].space[space].block= tv2;
//                                break;
//                                case e13:
//                                    if ( bodyIndex == 0 )
//                                        f1.name[newLabel].space[space].block= tv1;
//                                    else
//                                        f1.name[newLabel].space[space].block= tv3;
//                                    break;
//                                case e23:
//                                    if ( bodyIndex == 0 )
//                                        f1.name[newLabel].space[space].block= tv2;
//                                    else
//                                        f1.name[newLabel].space[space].block= tv3;
//                                    break;
//                                case e14:
//                                    if ( bodyIndex == 0 )
//                                        f1.name[newLabel].space[space].block= tv1;
//                                    else
//                                        f1.name[newLabel].space[space].block= tv4;
//                                    break;
//                                case e24:
//                                    if ( bodyIndex == 0 )
//                                        f1.name[newLabel].space[space].block= tv2;
//                                    else
//                                        f1.name[newLabel].space[space].block= tv4;
//                                    break;
//                                case e34:
//                                    if ( bodyIndex == 0 )
//                                        f1.name[newLabel].space[space].block= tv3;
//                                    else
//                                        f1.name[newLabel].space[space].block= tv4;
//                                    break;
//                                default:
//                                    f1.name[newLabel].space[space].block= bl;
//                                ///distribute bl commands
//                            }
//                        }
//                    }
//            }
//                {
//                            inta n;
//                            for ( n = 0 ; n < spin ; n++){
//                                f1.name[temp].Current[n]= 1;
//                                tEqua(f1, newLabel, n, temp, n);
//                            }
//                }
//                f1.name[currLoop].loopNext = newLabel;
//                f1.name[newLabel].species = hidden;
//                currLoop = newLabel;
//                }
//            }
//        }
//    return 0;
//}




/**
 *Not currently used, but contains information on pseudo-potentials
*/
inta buildMetric( double latticePause,inta Z,   function_label func,inta am,   metric_label * metric){
    inta dim,dimB,nMet = 0,ai,space;
    const inta psu_stride = 17;
    const inta psu_length = 11;
    double lda[] = {
        1, 1, 0, 2, 2, 0.2, -4.06633, 0.677832, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 3, 0, 4, 4, 0.4, -14.0094, 9.50991, -1.75327, 0.0834586, 0, 0, 0,0, 0, 0, 0,
        4, 4, 0, 4, 4, 0.325, -23.991, 17.1718, -3.31896,0.165083, 0, 0, 0, 0, 0, 0, 0,
        5, 3, 0, 3, 2, 0.4325, -5.60048,0.806284, 0, 0, 1, 0.373882, 6.23522, 0, 0, 0, 0,
        6, 4, 0, 3, 2,0.346473, -8.57533, 1.23413, 0, 0, 1, 0.304523, 9.53419, 0, 0, 0, 0,
        7, 5, 0, 3, 2, 0.288905, -12.2046, 1.75582, 0, 0, 1, 0.256912,0.256912, 0, 0, 0, 0,
        8, 6, 0, 3, 2, 0.247754, -16.4822, 2.37014, 0,0, 1, 0.222203, 18.1996, 0, 0, 0, 0,
        13, 3, 0, 6, 1, 0.45, -6.83406,0, 0, 0, 2, 0.465436, 2.81408, 1.93952, 3, 0.546243, 1.91601,
        14, 4,0, 6, 1, 0.44, -6.91363, 0, 0, 0, 2, 0.424334, 3.20813, 2.58888, 3,0.485359,2.65622,
        15, 5, 0, 6, 1, 0.43, -6.64097, 0, 0, 0, 2, 0.390738, 3.65826, 3.15066, 3, 0.440846, 3.28594,
        16, 6, 0, 6, 1,0.42, -6.59607, 0, 0, 0, 2, 0.362614, 4.22284, 3.66966, 3, 0.405311,3.88535};
    double blyp[] = {
        1, 1, 0, 2, 2, 0.2, -4.10561, 0.692787, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 3, 0, 4, 4, 0.4, -14.1026, 9.65027, -1.79063, 0.0857313, 0, 0, 0,0, 0, 0, 0,
        4, 4, 0, 4, 4, 0.325, -24.0586, 17.2529, -3.33239,0.165305, 0, 0, 0, 0, 0, 0, 0,
        5, 3, 0, 3, 2, 0.424087, -6.08744,0.980916, 0, 0, 1, 0.371141, 6.32735, 0, 0, 0, 0,
        6, 4, 0, 3, 2,0.337633, -9.12847, 1.42513, 0, 0, 1, 0.302528, 9.65073, 0, 0, 0, 0,
        7, 5, 0, 3, 2, 0.281959, -12.7548, 1.94859, 0, 0, 1, 0.255444,13.6594, 0, 0, 0, 0,
        8, 6, 0, 3, 2, 0.24245, -17.0171, 2.56133, 0, 0,1, 0.221084, 18.3556, 0, 0, 0, 0,
        13, 3, 0, 6, 1, 0.45, -5.54822, 0,0, 0, 2, 0.505838, 3.02008, 1.06418, 3, 0.577572, 1.53528,
        14, 4, 0,6, 1, 0.44, -5.97966, 0, 0, 0, 2, 0.444927, 3.4402, 1.88129, 3,0.503637, 2.28821,
        15, 5, 0, 6, 1, 0.43, -5.87283, 0, 0, 0, 2,0.403545, 3.8762, 2.54131, 3, 0.452751, 2.9405,
        16, 6, 0, 6, 1, 0.42,-6.0083, 0, 0, 0, 2, 0.370401, 4.37362, 3.19573, 3, 0.413079, 3.5911};
    double *def, *PSU;
    
    
    switch ( func.fn ){
        case Pseudo:
            if ( latticePause > 1./func.param[2] ){
                if ( am < 1 )
                    exit(1);
                metric[nMet].fn.fn = Pseudo;
                metric[nMet].fn.param[0] = -func.param[0];
                metric[nMet].fn.param[2] = func.param[2];
                metric[nMet].fn.interval = func.interval;
                metric[nMet].fn.contr    = func.contr;
                metric[nMet].metric = interval;
                metric[nMet].beta[0] = 0;
                metric[nMet].beta[1] = 1./func.param[2];
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }
                nMet++;
            }else {
                if ( am < 2 )
                    exit(1);
                metric[nMet].fn.fn = Pseudo;
                metric[nMet].fn.param[0] = -func.param[0];
                metric[nMet].fn.param[2] = func.param[2];
                metric[nMet].fn.interval     = func.interval;
                metric[nMet].fn.contr    = func.contr;
                metric[nMet].metric = interval;
                metric[nMet].beta[0] = 0;
                metric[nMet].beta[1] = latticePause;
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
                metric[nMet].fn.fn = Pseudo;
                metric[nMet].fn.param[0] = -func.param[0];
                metric[nMet].fn.param[2] = func.param[2];
                metric[nMet].fn.interval = func.interval;
                metric[nMet].fn.contr    = func.contr;
                metric[nMet].metric = interval;
                metric[nMet].beta[0] = latticePause;
                metric[nMet].beta[1] = 1./func.param[2];
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
            }
            break;
        case Coulomb:
        case Yukawa:
            if ( am < 2 )
                exit(1);
            metric[nMet].fn.fn = func.fn;
            metric[nMet].fn.param[0] = -func.param[0];
            metric[nMet].fn.param[2] = func.param[2];
            metric[nMet].fn.interval = func.interval;
            metric[nMet].fn.contr    = func.contr;
            metric[nMet].metric = interval;
            metric[nMet].beta[0] = 0;
            metric[nMet].beta[1] = latticePause;
            for ( space = 0; space < SPACE ; space++){
                metric[nMet].pow[space] = 0;
                metric[nMet].deriv[space] = 0;
            }

            nMet++;
            metric[nMet].fn.fn = func.fn;
            metric[nMet].fn.param[0] = -func.param[0];
            metric[nMet].fn.param[2] = func.param[2];
            metric[nMet].fn.interval = func.interval;
            metric[nMet].fn.contr    = func.contr;
            metric[nMet].metric = semiIndefinite;
            metric[nMet].beta[0] = latticePause;
            for ( space = 0; space < SPACE ; space++){
                metric[nMet].pow[space] = 0;
                metric[nMet].deriv[space] = 0;
            }

            nMet++;
            break;
        case LDA:
        case BLYP:
           if ( LDA == func.fn )
                def = lda;
            else if  ( BLYP == func.fn )
                def = blyp;
            else {
                printf("not known \n");
                exit(0);
            }
            PSU = NULL;
            for ( ai = 0; ai < psu_length ; ai++){
                if ( def[psu_stride*ai] ==  abs(Z))//one place Z actually matters...pseudo Z.
                    PSU = def+psu_stride * ai;
            }
            if ( PSU == NULL )
            {
                printf ("not coded\n");
                exit(0);
            }
            //add pseudo core.
            if ( latticePause > 1./(sqrt(2.)*PSU[5]) ){
                if ( am < 1 )
                    exit(1);
                metric[nMet].fn.fn = Pseudo;
                metric[nMet].fn.param[0] = -PSU[1];
                metric[nMet].fn.param[2] = (sqrt(2.)*PSU[5]);
                metric[nMet].fn.interval = func.interval;
                metric[nMet].fn.contr    = func.contr;
                metric[nMet].metric = interval;
                metric[nMet].beta[0] = 0;
                metric[nMet].beta[1] =  1./(sqrt(2.)*PSU[5]);
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
            }else {
                if ( am < 2 )
                    exit(1);
                metric[nMet].fn.fn = Pseudo;
                metric[nMet].fn.param[0] = -PSU[1];
                metric[nMet].fn.param[2] = (sqrt(2.)*PSU[5]);
                metric[nMet].fn.interval = func.interval;
                metric[nMet].fn.contr    = func.contr;
                metric[nMet].metric = interval;
                metric[nMet].beta[0] = 0;
                metric[nMet].beta[1] = latticePause;
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
                metric[nMet].fn.fn = Pseudo;
                metric[nMet].fn.param[0] = -PSU[1];
                metric[nMet].fn.param[2] = (sqrt(2.)*PSU[5]);
                metric[nMet].fn.interval = func.interval;
                metric[nMet].fn.contr    = func.contr;
                metric[nMet].metric = interval;
                metric[nMet].beta[0] = latticePause;
                metric[nMet].beta[1] =  1./(sqrt(2.)*PSU[5]);
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
            }
            if (fabs(PSU[6])> 0. ){
                //single gaussian
                metric[nMet].fn.fn = Gaussian;
                metric[nMet].fn.param[0] = PSU[6]/pow(PSU[5], 0);
                metric[nMet].fn.interval = 0;
                metric[nMet].metric = dirac;
                metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[5]);
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
                if ( nMet > am )
                    exit(1);
            }
            if (fabs(PSU[7])> 0. ){
                //3 gaussians.
                for ( dim = 0 ; dim < 3 ; dim++){
                    metric[nMet].fn.fn = Gaussian;
                    metric[nMet].fn.param[0] = PSU[7]/pow(PSU[5], 2);
                    metric[nMet].fn.interval = 0;
                    metric[nMet].metric = dirac;
                    metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[5]);
                    for ( space = 0; space < SPACE ; space++){
                        metric[nMet].pow[space] = 0;
                        metric[nMet].deriv[space] = 0;
                    }
                    metric[nMet].pow[dim] = 2;
                    
                    nMet++;
                    if ( nMet > am )
                        exit(1);
                }
            }
            if (fabs(PSU[8])> 0. ){
                //6 gaussians
                for ( dim = 0 ; dim < 6 ; dim++){
                    metric[nMet].fn.fn = Gaussian;
                    metric[nMet].fn.param[0]= PSU[8]/pow(PSU[5], 4);
                    metric[nMet].fn.interval = 0;
                    metric[nMet].metric = dirac;
                    metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[5]);
                    for ( space = 0; space < SPACE ; space++){
                        metric[nMet].pow[space] = 0;
                        metric[nMet].deriv[space] = 0;
                    }
                    //a^2 + 2 a b + b^2 + 2 a c + 2 b c + c^2

                    switch( dim ){
                        case 0:
                            metric[nMet].pow[0] = 4;
                            break;
                        case 1:
                            metric[nMet].fn.param[0] *= 2;
                            metric[nMet].pow[0] = 2;
                            metric[nMet].pow[1] = 2;
                            break;
                        case 2:
                            metric[nMet].pow[1] = 4;
                            break;
                        case 3:
                            metric[nMet].fn.param[0] *= 2;
                            metric[nMet].pow[1] = 2;
                            metric[nMet].pow[2] = 2;
                            break;
                        case 4:
                            metric[nMet].pow[2] =4;
                            break;
                        case 5:
                            metric[nMet].fn.param[0] *= 2;
                            metric[nMet].pow[0] = 2;
                            metric[nMet].pow[2] = 2;
                            break;
                            
                    }
                    
                    nMet++;
                    if ( nMet > am )
                        exit(1);

                }
            }
            if (fabs(PSU[9])> 0. ){
                //6 gaussians
                if ( SPACE < 3 ){
                    printf("ack!");
                    exit(1);
                }
                for ( dim = 0 ; dim < 10 ; dim++){
                    metric[nMet].fn.fn = Gaussian;
                    metric[nMet].fn.param[0] = PSU[9]/pow(PSU[5], 6);
                    metric[nMet].fn.interval = 0;
                    metric[nMet].metric = dirac;
                    metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[5]);
                    for ( space = 0; space < SPACE ; space++){
                        metric[nMet].pow[space] = 0;
                        metric[nMet].deriv[space] = 0;
                    }
                    //a^3 + 3 a^2 b + 3 a b^2 + b^3 + 3 a^2 c + 6 a b c + 3 b^2 c +
                    //3 a c^2 + 3 b c^2 + c^3
                    

                    switch( dim ){
                        case 0:
                            metric[nMet].pow[0] = 6;
                            break;
                        case 1:
                            metric[nMet].fn.param[0] *= 3;
                            metric[nMet].pow[0] = 4;
                            metric[nMet].pow[1] = 2;
                            break;
                        case 2:
                            metric[nMet].fn.param[0] *= 3;
                            metric[nMet].pow[0] = 2;
                            metric[nMet].pow[1] = 4;
                            break;
                        case 3:
                            metric[nMet].pow[1] = 6;
                            break;
                        case 4:
                            metric[nMet].fn.param[0] *= 3;
                            metric[nMet].pow[0] = 4;
                            metric[nMet].pow[2] = 2;
                            break;
                        case 5:
                            metric[nMet].fn.param[0] *= 6;
                            metric[nMet].pow[0] = 2;
                            metric[nMet].pow[1] = 2;
                            metric[nMet].pow[2] = 2;
                            break;
                        case 6:
                            metric[nMet].fn.param[0] *= 3;
                            metric[nMet].pow[1] = 4;
                            metric[nMet].pow[2] = 2;
                            break;
                        case 7:
                            metric[nMet].fn.param[0] *= 3;
                            metric[nMet].pow[0] = 2;
                            metric[nMet].pow[2] = 4;
                            break;
                        case 8:
                            metric[nMet].fn.param[0] *= 3;
                            metric[nMet].pow[1] = 2;
                            metric[nMet].pow[2] = 4;
                            break;
                        case 9:
                            metric[nMet].pow[2] = 6;
                            break;
                    }
                
                    nMet++;
                    if ( nMet > am )
                        exit(1);
                    
                }
            }
            if (fabs(PSU[10]) > 0. ){
                //single separated gaussian
                metric[nMet].fn.fn = Gaussian;
                metric[nMet].fn.param[0] = PSU[12]/pow(sqrt(pi)*PSU[11],3);
                metric[nMet].fn.interval= 0;
                metric[nMet].metric = separateDirac;
                metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[5]);
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].powB[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }

                nMet++;
                if ( nMet > am )
                    exit(1);
            }
            if (fabs(PSU[10]) > 1. ){
                //9 separated radial gaussian
                for ( dim = 0 ;dim < 3 ;dim++)
                    for ( dimB = 0 ;dimB < 3 ;dimB++){
                        metric[nMet].fn.fn = Gaussian;
                        metric[nMet].fn.param[0] = 2./15.*PSU[16]/pow(pi,1.500)/pow(PSU[15],7.);
                        metric[nMet].fn.interval = 0;
                        metric[nMet].metric = separateDirac;
                        metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[11]);
                        for ( space = 0; space < SPACE ; space++){
                            metric[nMet].pow[space] = 0;
                            metric[nMet].powB[space] = 0;
                            metric[nMet].deriv[space] = 0;
                        }
                        //(x2 + y2 + z2 ) ( x'2 + y'2 + z'2 )
                        metric[nMet].pow[dim] = 2;
                        metric[nMet].powB[dimB] = 2;
                        
                        nMet++;
                        if ( nMet > am )
                            exit(1);
                    }
            }
            if (fabs(PSU[14]) > 0. ){
                //3 separated p-gaussian
                for ( dim = 0 ;dim < 3 ;dim++){
                    metric[nMet].fn.fn = Gaussian;
                    metric[nMet].fn.param[0] = 2.*PSU[16]/pow(pi,1.500)/pow(PSU[15],5.);
                    metric[nMet].fn.interval = 0;
                    metric[nMet].metric = separateDirac;
                    metric[nMet].beta[0] =  1./(sqrt(2.)*PSU[15]);
                    for ( space = 0; space < SPACE ; space++){
                        metric[nMet].pow[space] = 0;
                        metric[nMet].deriv[space] = 0;
                    }
                    metric[nMet].pow[dim]  = 1;
                    metric[nMet].powB[dim] = 1;

                    nMet++;
                    if ( nMet > am )
                        exit(1);
                }
            }
            break;
        case Gaussian:
            
                //single gaussian
                metric[nMet].fn.fn = Gaussian;
                metric[nMet].fn.param[0] = func.param[0];
            metric[nMet].fn.param[2] = func.param[2];
                metric[nMet].fn.interval = 0;
                metric[nMet].metric = dirac;
                metric[nMet].beta[0] = func.param[2];
                for ( space = 0; space < SPACE ; space++){
                    metric[nMet].pow[space] = 0;
                    metric[nMet].deriv[space] = 0;
                }
                nMet++;
                if ( nMet > am )
                    exit(1);
            
            break;
        default:
            break;

    }
    
    return nMet;
}


/**
 *Eikon of Kinetic
 *
 * MAY NEED A BLOCH K
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline periodic
 *@param cmpl make it real for now
 */
inta buildKinetic( calculation *c1, sinc_label *f1,double scalar,inta invert,inta act, blockType bl, division single,inta label, inta overline, spinType cmpl){
    inta dim,spacy;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    printf("Kinetic\tx %d act %d block %d (%f)\n", label,act,bl,scalar);
    floata crystal = 0.;
    
    division currLabel,memoryLabel;
    currLabel = li;
    for ( dim = 0 ; dim < SPACE ; dim++)
        if ( f1->canon[dim].body != nada)
        {
            if ( f1->canon[dim].label == label)
                {
                    
                    f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                    currLabel = f1->name[currLabel].chainNext;
                    f1->name[currLabel].species = eikon;
                    //new term
                    f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                    memoryLabel = f1->name[currLabel].loopNext;
                    
                    if (f1->canon[dim].basis == SincBasisElement){
                    
                        f1->name[memoryLabel].species = eikonKinetic;
                        f1->name[memoryLabel].Current[0] = 1;

                
                        for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                            if ( f1->canon[spacy].body != nada){
                                f1->name[memoryLabel].space[spacy].act = act;
                                if ( f1->canon[spacy].label == label && spacy == dim)
                                    {
                                        f1->name[memoryLabel].space[spacy].body = one;
                                        f1->name[memoryLabel].space[spacy].block = bl;
                                        streams(*f1, memoryLabel, 0, spacy)[0] = -0.500*scalar;
                                    }else{
                                            f1->name[memoryLabel].space[spacy].block = id0;
                                    }
                        
                            }
                    }else {
                        f1->name[memoryLabel].species = eikonSplit;
                        f1->name[memoryLabel].Current[0] = 1;
                        for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                            if ( f1->canon[spacy].body != nada){
                                f1->name[memoryLabel].space[spacy].act = act;
                                if ( f1->canon[spacy].label == label && spacy == dim)
                                    {
                                        f1->name[memoryLabel].space[spacy].body = one;
                                        f1->name[memoryLabel].space[spacy].block = bl;
                                        inta I1,I2,n1;
                                        n1 = vector1Len(*f1,dim);
                                        for ( I1 = 0; I1 < n1; I1++)
                                            for ( I2 = 0; I2 < n1; I2++)
                                                streams(*f1, memoryLabel, 0, spacy)[I1*n1+I2] = -0.500*scalar*
                                                periodicSincfourierIntegralInTrain(I1, f1->canon[dim].particle[bl].lattice, f1->canon[dim].particle[bl].origin, f1->canon[dim].count1Basis, I2, f1->canon[dim].particle[bl].lattice, f1->canon[dim].particle[bl].origin,
                                                                                   f1->canon[dim].count1Basis, crystal, 0, 2);
                                    }else{
                                            f1->name[memoryLabel].space[spacy].block = id0;
                                    }
                        
                            }
                        
                        
                    }
                }
        }
        
        
        
        
    return 0;
}

/**
 *Eikon of a constant function
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
*/
inta buildConstant(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl){
    inta space;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("constant %f invert %d act %d block %d\n", scalar,invert,act,bl);
    division currLabel,memoryLabel;
    f1->name[li].chainNext = anotherLabel(f1,0,nada);
    currLabel = f1->name[li].chainNext;
    f1->name[currLabel].species = eikon;
    //new term
    f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
    memoryLabel = f1->name[currLabel].loopNext;
    f1->name[memoryLabel].species = eikonConstant;
    f1->name[memoryLabel].Current[0] = 1;
    
    for ( space = 0 ; space < SPACE ; space++)
        if ( f1->canon[space].body != nada){
            if ( f1->canon[space].label == label)
                {
                    f1->name[memoryLabel].space[space].block = bl;
                    f1->name[memoryLabel].space[space].act = act;
                    streams(*f1, memoryLabel, 0, space)[0] = scalar;//redundant and irrelevant.
                }else
                {
                    f1->name[memoryLabel].space[space].block = id0;
                    f1->name[memoryLabel].space[space].act = 1;
                }
            }
    return 0;
}


/**
 *Eikon of linear X function
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
*/
inta buildLinear(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl){
    inta dim,spacy;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Force\tx %d act %d block %d \t(%f)\n", label,act,bl,scalar);

         division currLabel,memoryLabel;
       currLabel = li;
       for ( dim = 0 ; dim < SPACE ; dim++)
           if ( f1->canon[dim].body != nada)
           {
               if ( f1->canon[dim].label == label)
                   {
                       
                       f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                       currLabel = f1->name[currLabel].chainNext;
                       f1->name[currLabel].species = eikon;
                       //new term
                       f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[currLabel].loopNext;
                       f1->name[memoryLabel].species = eikonLinear;
                       f1->name[memoryLabel].Current[0] = 1;

                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = 1;//i think this is weak, but not concerning now...
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
               }
           }

    return 0;
}


/**
 *Eikon of deriv operator
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
*/
inta buildDeriv(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl){
    inta dim,spacy,id=0;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Force\tx %d act %d block %d \t(%f)\n", label,act,bl,scalar);

         division memoryLabel,currLabel;
       currLabel = li;
       for ( dim = 0 ; dim < SPACE ; dim++)
           if ( f1->canon[dim].body != nada)
           {
               if ( f1->canon[dim].label == label)
                   {
                       
                       f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                       currLabel = f1->name[currLabel].chainNext;
                       f1->name[currLabel].species = eikon;
                       //new term
                       f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[currLabel].loopNext;
                       f1->name[memoryLabel].species = eikonDeriv;
                       f1->name[memoryLabel].Current[0] = 1;

                       ///set term across basis
                       for (spacy = 0 ; spacy < SPACE ; spacy++)
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = 1;//i think this is weak, but not concerning now...
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
               }
           }

    return 0;
}


/**
 *Eikon of state elements
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
 *@param bra an index of an element
 *@param ket an index of an element
*/
inta buildElement(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl,inta bra, inta ket){
    inta space;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Element\tx %d act %d block %d \t(%d,%d)->(%f)\n", label,act,bl,bra,ket,scalar);

      division currLabel;
    f1->name[li].chainNext = anotherLabel(f1,0,nada);
    currLabel = f1->name[li].chainNext;
    f1->name[currLabel].species = eikon;
    division memoryLabel = anotherLabel(f1,all,one);
    f1->name[currLabel].loopNext = memoryLabel;
    f1->name[memoryLabel].species = eikonElement;
    f1->name[memoryLabel].Current[0] = 1;

    for ( space = 0 ; space < SPACE ; space++)
        if ( f1->canon[space].body != nada){
            f1->name[currLabel].space[space].act = act;
            if ( f1->canon[space].label == label)
                {
                    f1->name[memoryLabel].space[space].body = one;

                    streams(*f1, memoryLabel, 0, space)[0] = scalar;
                    f1->name[memoryLabel].space[space].block = tv1;
                    f1->name[memoryLabel].space[space].bra = bra;
                    f1->name[memoryLabel].space[space].ket = ket;
                }else
                {
                    f1->name[memoryLabel].space[space].block = id0;
                }
            }

    return 0;
}




/**
 *Eikon of square X function
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
*/
inta buildSpring(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl){
    inta dim,spacy,id=0;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Spring\tx %d act %d block %d (%f)\n", label,act,bl,scalar);

    
         division memoryLabel,currLabel;
       currLabel = li;
       for ( dim = 0 ; dim < SPACE ; dim++)
           if ( f1->canon[dim].body != nada)
           {
               if ( f1->canon[dim].label == label)
                   {

                       f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                       currLabel = f1->name[currLabel].chainNext;
                       f1->name[currLabel].species = eikon;
                       //new term
                       f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[currLabel].loopNext;
                       f1->name[memoryLabel].species = eikonSpring;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = 0.500*scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
               }
           }
               return 0;
}


/**
 *Eikon of Number Operator
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
 *@param omega spatial definition of SHO
*/
inta buildNumber(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl, floata omega){
    inta dim,spacy;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Number\tx %d act %d block %d (%f)\n", label,act,bl,scalar);

    
         division memoryLabel,currLabel;
       currLabel = li;
       for ( dim = 0 ; dim < SPACE ; dim++)
           if ( f1->canon[dim].body != nada)
           {
               if ( f1->canon[dim].label == label)
                   {

                       f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                       currLabel = f1->name[currLabel].chainNext;
                       f1->name[currLabel].species = eikon;
                       //new term
                       f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[currLabel].loopNext;
                       f1->name[memoryLabel].species = eikonSpring;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = 0.500*scalar*omega*omega;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
                       
                       f1->name[memoryLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[memoryLabel].loopNext;
                       f1->name[memoryLabel].species = eikonKinetic;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = 0.500*scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
                       
               }
           }
               return 0;
}

/**
 *Eikon of Creation Operator
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
 *@param omega spatial definition of SHO
*/
inta buildCreate(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl, floata omega){
    inta dim,spacy;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Number\tx %d act %d block %d (%f)\n", label,act,bl,scalar);

    
         division memoryLabel,currLabel;
       currLabel = li;
       for ( dim = 0 ; dim < SPACE ; dim++)
           if ( f1->canon[dim].body != nada)
           {
               if ( f1->canon[dim].label == label)
                   {

                       f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                       currLabel = f1->name[currLabel].chainNext;
                       f1->name[currLabel].species = eikon;
                       //new term
                       f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[currLabel].loopNext;
                       f1->name[memoryLabel].species = eikonLinear;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = sqrt(0.500*omega)*scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
                       
                       f1->name[memoryLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[memoryLabel].loopNext;
                       f1->name[memoryLabel].species = eikonDeriv;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = sqrt(0.500/omega)*scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
                       
               }
           }
               return 0;
}

/**
 *Eikon of Destruction Operator
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param label the component group ID
 *@param overline legacy
 *@param cmpl make it real for now
 *@param omega spatial definition of SHO
*/
inta buildDestroy(  calculation *c1,   sinc_label *f1,double scalar,inta invert,inta act,   blockType bl,  division single,inta label, inta overline,   spinType cmpl, floata omega){
    inta dim,spacy;
      division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    //x is beta.
    if ( overline ){
        printf("periodic boundary conditions not implemented yet!");
        exit(0);
    }
    printf("Number\tx %d act %d block %d (%f)\n", label,act,bl,scalar);

    
         division memoryLabel,currLabel;
       currLabel = li;
       for ( dim = 0 ; dim < SPACE ; dim++)
           if ( f1->canon[dim].body != nada)
           {
               if ( f1->canon[dim].label == label)
                   {

                       f1->name[currLabel].chainNext = anotherLabel(f1,0,nada);
                       currLabel = f1->name[currLabel].chainNext;
                       f1->name[currLabel].species = eikon;
                       //new term
                       f1->name[currLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[currLabel].loopNext;
                       f1->name[memoryLabel].species = eikonLinear;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = sqrt(0.500*omega)*scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
                       
                       f1->name[memoryLabel].loopNext = anotherLabel(f1,all,one);
                       memoryLabel = f1->name[memoryLabel].loopNext;
                       f1->name[memoryLabel].species = eikonDeriv;
                       f1->name[memoryLabel].Current[0] = 1;

               
                       for (spacy = 0 ; spacy < SPACE ; spacy++)//set term across basis
                           if ( f1->canon[spacy].body != nada){
                               f1->name[memoryLabel].space[spacy].act = act;
                               if ( f1->canon[spacy].label == label && spacy == dim)
                                   {
                                       f1->name[memoryLabel].space[spacy].body = one;
                                       f1->name[memoryLabel].space[spacy].block = bl;
                                       streams(*f1, memoryLabel, 0, spacy)[0] = -sqrt(0.500/omega)*scalar;
                                   }else{
                                           f1->name[memoryLabel].space[spacy].block = id0;
                                   }
                       
                           }
                       
               }
           }
               return 0;
}

/**
 *Eikon of oneBody interaction
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] single linked list
 *@param particle1 the component group ID
 *@param embed the number of trivial argumented Gaussians
 *@param overline legacy
 *@param cmpl make it real for now
 *@param mu the metric
 *@param a geometry/Z of a-th ion
 */
inta buildExternalPotential(  calculation *c1,   sinc_label *f1,double scalar, inta invert,inta act,  blockType bl,   division single,  inta *particle1,inta embed, inta overline,   spinType cmpl,  metric_label mu,inta a){
    inta ra=0;
    printf("oneBody act %d block %d atom %d >%d<\n", act,bl, a,embed);
    getDescription(&mu.fn, scalar, stdout);
    getMetric(mu, stdout);
            if ( mu.metric == interval || mu.metric == semiIndefinite)
                ra += (mu.fn.interval);
            else if ( mu.metric == dirac )
                ra++;
            
    if ( bootedQ(*f1) ){
            {
            separateInteraction(f1,scalar*c1->i.atoms[a].Z, c1->i.atoms[a].position+1,invert,act,bl, single, mu, cmpl, overline,0, particle1,one,embed);
            }
//    else
//    {
//
//
//        if ( f1->canon[0].basis == SincBasisElement ){
//            inta space,body;
//            momentumIntegralSpecs specs;
//            specs.metric = continousMomentum;
//            floata ml = f1->canon[0].particle[one].lattice;
//            for (space = 0 ; space < SPACE ; space++)
//            if ( f1->canon[space].body != nada){
//                if ( f1->canon[space].label == particle1[0] )
//                    for ( body = one ; body <= f1->canon[space].body ; body++)
//                        ml = fmin( ml, f1->canon[space].particle[body].lattice);
//                }
//            specs.maxMomentum = 2.*pi/ml;
//            splitInteraction(f1, scalar*c1->i.atoms[a].Z, c1->i.atoms[a].position+1, invert, act, bl, single, mu, cmpl, specs, 0, particle1, one, embed);
//        }
//        else{
//            momentumIntegralSpecs specs;
//            specs.metric = discreteMomentum;
//            specs.interval = f1->canon[0].count1Basis-1;
//            periodicInteraction(f1, scalar*c1->i.atoms[a].Z,c1->i.atoms[a].position+1,invert,act,bl, single , mu, cmpl,specs, f1->canon[0].count1Basis*f1->canon[0].particle[one].lattice, 0, particle1,one);
//        }
//            }

    }
    return ra;
}

/**
 *Eikon of twoBody interaction
 *
 *@param c1 parameters
 *@param f1 container
 *@param scalar overall scalar multiply
 *@param invert switch to turn on a particle-1 inversion
 *@param act Symmetry Adaption related work, for group action
 *@param bl the address of the interaction, i.e. particle-1 or particle-12
 *@param[in] pair linked list
 *@param particle1 the component group ID
 *@param embed the number of trivial argumented Gaussians
 *@param overline legacy
 *@param cmpl make it real for now
 *@param mu the metric
*/
inta buildPairWisePotential(  calculation *c1,   sinc_label *f1,double scalar,inta invert, inta act,  blockType bl,  division pair,  inta *particle1 ,inta embed, inta overline,   spinType cmpl,  metric_label mu){
    inta ra=0;
    printf("twoBody act %d block %d >%d<\n",act,bl,embed);
    getDescription(&mu.fn, scalar, stdout);
    getMetric(mu, stdout);
    double zero[6];
    zero[0] = 0.;
    zero[1] = 0.;
    zero[2] = 0.;
    zero[3] = 0.;
    zero[4] = 0.;
    zero[5] = 0.;

    if ( mu.metric == interval || mu.metric == semiIndefinite)
        ra += (mu.fn.interval);
    else if ( mu.metric == dirac )
        ra++;
    if ( bootedQ(*f1) ){
        {
            separateInteraction(f1, scalar,zero,invert,act,bl, pair , mu, cmpl,overline,0, particle1,two,embed);
        }
//        else {
//        if ( f1->canon[0].basis == SincBasisElement ){
//            inta space,body;
//            momentumIntegralSpecs specs;
//            specs.metric = continousMomentum;
//            floata ml = f1->canon[0].particle[one].lattice;
//            for (space = 0 ; space < SPACE ; space++)
//            if ( f1->canon[space].body != nada){
//                if ( f1->canon[space].label == particle1[0] || f1->canon[space].label == particle1[1])
//                    for ( body = one ; body <= f1->canon[space].body ; body++)
//                        ml = fmin( ml, f1->canon[space].particle[body].lattice);
//                }
//            specs.maxMomentum = 2.*pi/ml;
//            splitInteraction(f1, scalar, zero, invert, act, bl, pair, mu, cmpl, specs, 0, particle1, two, embed);
//        }
//        else{
//            momentumIntegralSpecs specs;
//            specs.metric = discreteMomentum;
//            specs.interval = f1->canon[0].count1Basis-1;
//            periodicInteraction(f1, scalar,zero,invert,act,bl, pair , mu, cmpl,specs, f1->canon[0].count1Basis*f1->canon[0].particle[one].lattice, 0, particle1,two);
//        }
//    }
    }
    return ra;
}


/**
 *Diagonal Matrix reference
 *
 *@param f field
 *@param filename file to put into vectorDiagonalMatrix, be sure to switch it on!
 *@param[in] single linked list
 */
inta assignDiagonalMatrix(calculation *c1,   field *f, char * filename, division single){
    sinc_label * f1 = &f->f;
    inta index = 0;
    division li = single;
    while ( f1->name[li].chainNext != nullName)
        li =f1->name[li].chainNext;
    printf("diagonalMatrix %s\n",filename);
    division headLabel;
    headLabel = anotherLabel(f1,0,nada);
    f1->name[li].chainNext = headLabel;
    f1->name[headLabel].Current[0] = 1;
 
    f1->name[headLabel].loopNext = vectorDiagonalMatrix;
    
    f1->name[vectorDiagonalMatrix].species = diagonalMatrix;
#ifndef APPLE
    tLoadEigenWeights(c1,f,filename, &index, vectorDiagonalMatrix, 0);
#else
    tBoot(f->f, vectorDiagonalMatrix, 0, 1);
#endif
    return 0;
}
